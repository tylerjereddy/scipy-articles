{
    "cluster.HierarchyLinkage.time_linkage": {
        "code": "class HierarchyLinkage:\n    def time_linkage(self, method):\n        linkage(self.X, method=method)", 
        "min_run_count": 2, 
        "name": "cluster.HierarchyLinkage.time_linkage", 
        "number": 0, 
        "param_names": [
            "method"
        ], 
        "params": [
            [
                "'single'", 
                "'complete'", 
                "'average'", 
                "'weighted'", 
                "'centroid'", 
                "'median'", 
                "'ward'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "886a23bad5fa5a00c76656791c898c69a0805a80db466949f34edc28f9ce00bd", 
        "warmup_time": -1
    }, 
    "cluster.KMeans.time_kmeans": {
        "code": "class KMeans:\n    def time_kmeans(self, k):\n        kmeans(self.obs, k, iter=10)", 
        "min_run_count": 2, 
        "name": "cluster.KMeans.time_kmeans", 
        "number": 0, 
        "param_names": [
            "k"
        ], 
        "params": [
            [
                "2", 
                "10", 
                "50"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "62d888a0d1080159d649bb8fd1de0cfe8b8b1f892bbeeb7f60de3bf620d20ffb", 
        "warmup_time": -1
    }, 
    "cluster.KMeans.time_kmeans2": {
        "code": "class KMeans:\n    def time_kmeans2(self, k):\n        kmeans2(self.obs, k, iter=10)", 
        "min_run_count": 2, 
        "name": "cluster.KMeans.time_kmeans2", 
        "number": 0, 
        "param_names": [
            "k"
        ], 
        "params": [
            [
                "2", 
                "10", 
                "50"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "c81461b97a6926a305c065d4fca0e3b548bedcd26b8d4ba8e9af249b44b1a8bc", 
        "warmup_time": -1
    }, 
    "cluster.VQ.time_vq": {
        "code": "class VQ:\n    def time_vq(self, k, dtype):\n        vq(self.obs, self.cbook)\n\n    def setup(self, k, dtype):\n        self.obs = self.data.astype(dtype)\n        self.cbook = self.cbook_source[:k].astype(dtype)", 
        "min_run_count": 2, 
        "name": "cluster.VQ.time_vq", 
        "number": 0, 
        "param_names": [
            "k", 
            "dtype"
        ], 
        "params": [
            [
                "2", 
                "10", 
                "50"
            ], 
            [
                "'float32'", 
                "'float64'", 
                "'float128'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "a8ef1a2c1ab11f03bd5a06903492b4472e58f2c62499acb3b715e3cf963ee3f0", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_airy_D": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_airy_D", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'airy_D'"
            ], 
            [
                "(1,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_airy_d": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_airy_d", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'airy_d'"
            ], 
            [
                "(1,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_beta_dd": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_beta_dd", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'beta_dd'"
            ], 
            [
                "(0.25, 0.75)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_erf_D": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_erf_D", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'erf_D'"
            ], 
            [
                "((1+1j),)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_erf_d": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_erf_d", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'erf_d'"
            ], 
            [
                "(1,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_exprel_d": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_exprel_d", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'exprel_d'"
            ], 
            [
                "(1e-06,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_gamma_D": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_gamma_D", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'gamma_D'"
            ], 
            [
                "((100+100j),)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_gamma_d": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_gamma_d", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'gamma_d'"
            ], 
            [
                "(100,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_jv_dD": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_jv_dD", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'jv_dD'"
            ], 
            [
                "(1, (1+1j))"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_jv_dd": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_jv_dd", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'jv_dd'"
            ], 
            [
                "(1, 1)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_loggamma_D": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_loggamma_D", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'loggamma_D'"
            ], 
            [
                "(20,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_logit_d": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_logit_d", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'logit_d'"
            ], 
            [
                "(0.5,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_psi_D": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_psi_D", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'psi_D'"
            ], 
            [
                "(1,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "cython_special.CythonSpecial.time_psi_d": {
        "code": "class CythonSpecial:\n    @with_attributes(params=[(name,), (args,)] + params,\n                     param_names=['name', 'argument'] + param_names)\n    def func(self, name, args, N, api):\n        if api == 'python':\n            self.py_func(N, *args)\n        elif api == 'numpy':\n            self.np_func(*self.obj)\n        else:\n            self.cy_func(N, *args)\n\n    def setup(self, name, args, N, api):\n        self.py_func = getattr(cython_special, '_bench_{}_py'.format(name))\n        self.cy_func = getattr(cython_special, '_bench_{}_cy'.format(name))\n        m = re.match('^(.*)_[dDl]+$', name)\n        self.np_func = getattr(special, m.group(1))\n    \n        self.obj = []\n        for arg in args:\n            self.obj.append(arg*np.ones(N))\n        self.obj = tuple(self.obj)", 
        "min_run_count": 2, 
        "name": "cython_special.CythonSpecial.time_psi_d", 
        "number": 0, 
        "param_names": [
            "name", 
            "argument", 
            "N", 
            "api"
        ], 
        "params": [
            [
                "'psi_d'"
            ], 
            [
                "(1,)"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'python'", 
                "'numpy'", 
                "'cython'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2121d6d387b76de2ad74448691075077459e395a49b4e28974ef714660a6275a", 
        "warmup_time": -1
    }, 
    "fftpack_basic.Fft.time_fft": {
        "code": "class Fft:\n    def time_fft(self, size, cmplx, module):\n        if module == 'numpy':\n            numpy.fft.fft(self.x)\n        else:\n            fft(self.x)\n\n    def setup(self, size, cmplx, module):\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)", 
        "min_run_count": 2, 
        "name": "fftpack_basic.Fft.time_fft", 
        "number": 0, 
        "param_names": [
            "size", 
            "type", 
            "module"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'real'", 
                "'cmplx'"
            ], 
            [
                "'scipy'", 
                "'numpy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "3aff55e305e25e0e32b603d61aa9997dcd6581ce7c4dd90fa462746a5092b07f", 
        "warmup_time": -1
    }, 
    "fftpack_basic.Fft.time_ifft": {
        "code": "class Fft:\n    def time_ifft(self, size, cmplx, module):\n        if module == 'numpy':\n            numpy.fft.ifft(self.x)\n        else:\n            ifft(self.x)\n\n    def setup(self, size, cmplx, module):\n        if cmplx == 'cmplx':\n            self.x = random([size]).astype(cdouble)+random([size]).astype(cdouble)*1j\n        else:\n            self.x = random([size]).astype(double)", 
        "min_run_count": 2, 
        "name": "fftpack_basic.Fft.time_ifft", 
        "number": 0, 
        "param_names": [
            "size", 
            "type", 
            "module"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'real'", 
                "'cmplx'"
            ], 
            [
                "'scipy'", 
                "'numpy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "008f387d5c1b7d2810b8e3cc767a6fb48810731cc49eb62b417e17622a87bbb5", 
        "warmup_time": -1
    }, 
    "fftpack_basic.Fftn.time_fftn": {
        "code": "class Fftn:\n    def time_fftn(self, size, cmplx, module):\n        if module == 'numpy':\n            numpy.fft.fftn(self.x)\n        else:\n            fftn(self.x)\n\n    def setup(self, size, cmplx, module):\n        size = map(int, size.split(\"x\"))\n    \n        if cmplx != 'cmplx':\n            self.x = random(size).astype(double)\n        else:\n            self.x = random(size).astype(cdouble)+random(size).astype(cdouble)*1j", 
        "min_run_count": 2, 
        "name": "fftpack_basic.Fftn.time_fftn", 
        "number": 0, 
        "param_names": [
            "size", 
            "type", 
            "module"
        ], 
        "params": [
            [
                "'100x100'", 
                "'1000x100'", 
                "'256x256'", 
                "'512x512'"
            ], 
            [
                "'real'", 
                "'cmplx'"
            ], 
            [
                "'scipy'", 
                "'numpy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "7b630bc6eb41ec0eab713d35b6318dea7a11d785891dae4add928eaac6ed95a4", 
        "warmup_time": -1
    }, 
    "fftpack_basic.RFft.time_irfft": {
        "code": "class RFft:\n    def time_irfft(self, size, module):\n        if module == 'numpy':\n            numpy.fft.irfft(self.x)\n        else:\n            irfft(self.x)\n\n    def setup(self, size, module):\n        self.x = random([size]).astype(double)", 
        "min_run_count": 2, 
        "name": "fftpack_basic.RFft.time_irfft", 
        "number": 0, 
        "param_names": [
            "size", 
            "module"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'scipy'", 
                "'numpy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "13be885c1ec56783c23a3adadfcf2ee885d406286732b267966297f56e7413d7", 
        "warmup_time": -1
    }, 
    "fftpack_basic.RFft.time_rfft": {
        "code": "class RFft:\n    def time_rfft(self, size, module):\n        if module == 'numpy':\n            numpy.fft.rfft(self.x)\n        else:\n            rfft(self.x)\n\n    def setup(self, size, module):\n        self.x = random([size]).astype(double)", 
        "min_run_count": 2, 
        "name": "fftpack_basic.RFft.time_rfft", 
        "number": 0, 
        "param_names": [
            "size", 
            "module"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'scipy'", 
                "'numpy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "7e70efc048f83ce0315bd4ca86fed1547b556fe144bf8549408a03b900e75b30", 
        "warmup_time": -1
    }, 
    "fftpack_pseudo_diffs.Bench.time_diff": {
        "code": "class Bench:\n    def time_diff(self, size, soltype):\n        if soltype == 'fft':\n            diff(self.f, 3)\n        else:\n            direct_diff(self.f, 3)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", 
        "min_run_count": 2, 
        "name": "fftpack_pseudo_diffs.Bench.time_diff", 
        "number": 0, 
        "param_names": [
            "size", 
            "type"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'fft'", 
                "'direct'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "ecbb51be15a54011afaf7419e4de58bf02949a7abc534276a2a18849eef9985d", 
        "warmup_time": -1
    }, 
    "fftpack_pseudo_diffs.Bench.time_hilbert": {
        "code": "class Bench:\n    def time_hilbert(self, size, soltype):\n        if soltype == 'fft':\n            hilbert(self.f)\n        else:\n            direct_hilbert(self.f)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", 
        "min_run_count": 2, 
        "name": "fftpack_pseudo_diffs.Bench.time_hilbert", 
        "number": 0, 
        "param_names": [
            "size", 
            "type"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'fft'", 
                "'direct'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8b3864453f4e979dcd4238fbebaaa50967556fc1ad60bcd23efb503a899b40d5", 
        "warmup_time": -1
    }, 
    "fftpack_pseudo_diffs.Bench.time_shift": {
        "code": "class Bench:\n    def time_shift(self, size, soltype):\n        if soltype == 'fft':\n            shift(self.f, self.a)\n        else:\n            direct_shift(self.f, self.a)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", 
        "min_run_count": 2, 
        "name": "fftpack_pseudo_diffs.Bench.time_shift", 
        "number": 0, 
        "param_names": [
            "size", 
            "type"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'fft'", 
                "'direct'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "4af1e866705c2b2da21bb261c884019e967221fc2e7a27937a0fa09e012bb221", 
        "warmup_time": -1
    }, 
    "fftpack_pseudo_diffs.Bench.time_tilbert": {
        "code": "class Bench:\n    def time_tilbert(self, size, soltype):\n        if soltype == 'fft':\n            tilbert(self.f, 1)\n        else:\n            direct_tilbert(self.f, 1)\n\n    def setup(self, size, type):\n        size = int(size)\n    \n        x = arange(size)*2*pi/size\n        a = 1\n        self.a = a\n        if size < 2000:\n            self.f = sin(x)*cos(4*x)+exp(sin(3*x))\n            self.sf = sin(x+a)*cos(4*(x+a))+exp(sin(3*(x+a)))\n        else:\n            self.f = sin(x)*cos(4*x)\n            self.sf = sin(x+a)*cos(4*(x+a))", 
        "min_run_count": 2, 
        "name": "fftpack_pseudo_diffs.Bench.time_tilbert", 
        "number": 0, 
        "param_names": [
            "size", 
            "type"
        ], 
        "params": [
            [
                "100", 
                "256", 
                "512", 
                "1000", 
                "1024", 
                "2048", 
                "4096", 
                "8192"
            ], 
            [
                "'fft'", 
                "'direct'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "9c700f861e3acd4a87c8e6abbd4fc60967a0ab446c25ea480db726774354ffa4", 
        "warmup_time": -1
    }, 
    "integrate.Quad.time_quad_cffi": {
        "code": "class Quad:\n    def time_quad_cffi(self):\n        quad(self.f_cffi, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        lib = ctypes.CDLL(clib_test.__file__)\n    \n        self.f_ctypes = lib._multivariate_sin\n        self.f_ctypes.restype = ctypes.c_double\n        self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)  # sic -- for backward compat\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", 
        "min_run_count": 2, 
        "name": "integrate.Quad.time_quad_cffi", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "d50bd77d39f34a0f30a0e84e456e77c12ad683a920d000324333e84e1ddaa428", 
        "warmup_time": -1
    }, 
    "integrate.Quad.time_quad_ctypes": {
        "code": "class Quad:\n    def time_quad_ctypes(self):\n        quad(self.f_ctypes, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        lib = ctypes.CDLL(clib_test.__file__)\n    \n        self.f_ctypes = lib._multivariate_sin\n        self.f_ctypes.restype = ctypes.c_double\n        self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)  # sic -- for backward compat\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", 
        "min_run_count": 2, 
        "name": "integrate.Quad.time_quad_ctypes", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "fde1038439e08919b189ed97d02faaa70c57085800438a9a01f725a5d976b545", 
        "warmup_time": -1
    }, 
    "integrate.Quad.time_quad_cython": {
        "code": "class Quad:\n    def time_quad_cython(self):\n        quad(self.f_cython, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        lib = ctypes.CDLL(clib_test.__file__)\n    \n        self.f_ctypes = lib._multivariate_sin\n        self.f_ctypes.restype = ctypes.c_double\n        self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)  # sic -- for backward compat\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", 
        "min_run_count": 2, 
        "name": "integrate.Quad.time_quad_cython", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "c9fd2eb3ae4dd44299830e2276e0eb58f759f090c1cbfef138102b8039a602ee", 
        "warmup_time": -1
    }, 
    "integrate.Quad.time_quad_python": {
        "code": "class Quad:\n    def time_quad_python(self):\n        quad(self.f_python, 0, np.pi)\n\n    def setup(self):\n        from math import sin\n    \n        self.f_python = lambda x: sin(x)\n        self.f_cython = from_cython(_ccallback_c, \"sine\")\n    \n        lib = ctypes.CDLL(clib_test.__file__)\n    \n        self.f_ctypes = lib._multivariate_sin\n        self.f_ctypes.restype = ctypes.c_double\n        self.f_ctypes.argtypes = (ctypes.c_int, ctypes.c_double)  # sic -- for backward compat\n    \n        if cffi is not None:\n            voidp = ctypes.cast(self.f_ctypes, ctypes.c_void_p)\n            address = voidp.value\n            ffi = cffi.FFI()\n            self.f_cffi = LowLevelCallable(ffi.cast(\"double (*)(int, double *)\", address))", 
        "min_run_count": 2, 
        "name": "integrate.Quad.time_quad_python", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "369273f34f9ff8f7cbd076413c703dd5773efc0aa74c649e1f103bcb19bf0c35", 
        "warmup_time": -1
    }, 
    "integrate.SolveBVP.time_flow": {
        "code": "class SolveBVP:\n    def time_flow(self):\n        x = np.linspace(0, 1, 10)\n        y = np.ones((7, x.size))\n        solve_bvp(self.fun_flow, self.bc_flow, x, y, p=[1], tol=self.TOL)", 
        "min_run_count": 2, 
        "name": "integrate.SolveBVP.time_flow", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "293d0d48d7da84b9911e7dc04cf3e31bdb1a4397e68597d8833cd1e39757f2b0", 
        "warmup_time": -1
    }, 
    "integrate.SolveBVP.time_gas": {
        "code": "class SolveBVP:\n    def time_gas(self):\n        x = np.linspace(0, 3, 5)\n        y = np.empty((2, x.size))\n        y[0] = 0.5\n        y[1] = -0.5\n        solve_bvp(self.fun_gas, self.bc_gas, x, y, tol=self.TOL)", 
        "min_run_count": 2, 
        "name": "integrate.SolveBVP.time_gas", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "62ed65f56095bdfe5e0cb9b1ed557471ee4156fd3ce8778282a49bc79625b19c", 
        "warmup_time": -1
    }, 
    "integrate.SolveBVP.time_peak": {
        "code": "class SolveBVP:\n    def time_peak(self):\n        x = np.linspace(-1, 1, 5)\n        y = np.zeros((2, x.size))\n        solve_bvp(self.fun_peak, self.bc_peak, x, y, tol=self.TOL)", 
        "min_run_count": 2, 
        "name": "integrate.SolveBVP.time_peak", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "b4c8fe896d280ca8d3be45f4f837d03ef487b935598f20e10e080f9ca6c20c1c", 
        "warmup_time": -1
    }, 
    "interpolate.BenchPPoly.time_evaluation": {
        "code": "class BenchPPoly:\n    def time_evaluation(self):\n        self.pp(self.xp)\n\n    def setup(self):\n        np.random.seed(1234)\n        m, k = 55, 3\n        x = np.sort(np.random.random(m+1))\n        c = np.random.random((3, m))\n        self.pp = interpolate.PPoly(c, x)\n    \n        npts = 100\n        self.xp = np.linspace(0, 1, npts)", 
        "min_run_count": 2, 
        "name": "interpolate.BenchPPoly.time_evaluation", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "7b3c30a7aae410ff669a6194881961262f69b80709978c3720fbaa41a48e0ffa", 
        "warmup_time": -1
    }, 
    "interpolate.BivariateSpline.time_lsq_bivariate_spline": {
        "code": "class BivariateSpline:\n    def time_lsq_bivariate_spline(self, n_samples):\n        interpolate.LSQBivariateSpline(self.x, self.y, self.z, self.xknots.flat, self.yknots.flat)\n\n    def setup(self, n_samples):\n        x = np.arange(0, n_samples, 0.5)\n        y = np.arange(0, n_samples, 0.5)\n        x, y = np.meshgrid(x, y)\n        x = x.ravel()\n        y = y.ravel()\n        xmin = x.min()-1\n        xmax = x.max()+1\n        ymin = y.min()-1\n        ymax = y.max()+1\n        s = 1.1\n        self.yknots = np.linspace(ymin+s, ymax-s, 10)\n        self.xknots = np.linspace(xmin+s, xmax-s, 10)\n        self.z = np.sin(x) + 0.1*np.random.normal(size=x.shape)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "interpolate.BivariateSpline.time_lsq_bivariate_spline", 
        "number": 0, 
        "param_names": [
            "n_samples"
        ], 
        "params": [
            [
                "10", 
                "20", 
                "30"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "26edc79385876a35063595d97558e84b15b2853afa424174781e5b6519cf0c15", 
        "warmup_time": -1
    }, 
    "interpolate.BivariateSpline.time_smooth_bivariate_spline": {
        "code": "class BivariateSpline:\n    def time_smooth_bivariate_spline(self, n_samples):\n        interpolate.SmoothBivariateSpline(self.x, self.y, self.z)\n\n    def setup(self, n_samples):\n        x = np.arange(0, n_samples, 0.5)\n        y = np.arange(0, n_samples, 0.5)\n        x, y = np.meshgrid(x, y)\n        x = x.ravel()\n        y = y.ravel()\n        xmin = x.min()-1\n        xmax = x.max()+1\n        ymin = y.min()-1\n        ymax = y.max()+1\n        s = 1.1\n        self.yknots = np.linspace(ymin+s, ymax-s, 10)\n        self.xknots = np.linspace(xmin+s, xmax-s, 10)\n        self.z = np.sin(x) + 0.1*np.random.normal(size=x.shape)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "interpolate.BivariateSpline.time_smooth_bivariate_spline", 
        "number": 0, 
        "param_names": [
            "n_samples"
        ], 
        "params": [
            [
                "10", 
                "20", 
                "30"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8875044efdaa5468cee675d6cbafc5eec34054c8cb8e3dcbdeb62354818ef8af", 
        "warmup_time": -1
    }, 
    "interpolate.GridData.time_evaluation": {
        "code": "class GridData:\n    def time_evaluation(self, n_grids, method):\n        interpolate.griddata(self.points, self.values, (self.grid_x, self.grid_y), method=method)\n\n    def setup(self, n_grids, method):\n        self.func = lambda x, y: x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2\n        self.grid_x, self.grid_y = np.mgrid[0:1:n_grids, 0:1:n_grids]\n        self.points = np.random.rand(1000, 2)\n        self.values = self.func(self.points[:, 0], self.points[:, 1])", 
        "min_run_count": 2, 
        "name": "interpolate.GridData.time_evaluation", 
        "number": 0, 
        "param_names": [
            "n_grids", 
            "method"
        ], 
        "params": [
            [
                "10j", 
                "100j", 
                "1000j"
            ], 
            [
                "'nearest'", 
                "'linear'", 
                "'cubic'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "923d16af64b5a3a7b7c90d693c0d51555c0b3434cb436920a0e400d9ec8ada02", 
        "warmup_time": -1
    }, 
    "interpolate.Interpolate.time_interpolate": {
        "code": "class Interpolate:\n    def time_interpolate(self, n_samples, module):\n        if module == 'scipy':\n            interpolate.interp1d(self.x, self.y, kind=\"linear\")\n        else:\n            np.interp(self.z, self.x, self.y)\n\n    def setup(self, n_samples, module):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.z = np.random.normal(size=self.x.shape)", 
        "min_run_count": 2, 
        "name": "interpolate.Interpolate.time_interpolate", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "module"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "c7f060979e3517fffcbf1a369ef545515a013076ac2c659ccdf1596a636cc394", 
        "warmup_time": -1
    }, 
    "interpolate.Interpolate1d.time_interpolate": {
        "code": "class Interpolate1d:\n    def time_interpolate(self, n_samples, method):\n        \"\"\"Time the construction overhead.\"\"\"\n        interpolate.interp1d(self.x, self.y, kind=method)\n\n    def setup(self, n_samples, method):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.interpolator = interpolate.interp1d(self.x, self.y, kind=method)\n        self.xp = np.linspace(self.x[0], self.x[-1], 4*n_samples)", 
        "min_run_count": 2, 
        "name": "interpolate.Interpolate1d.time_interpolate", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "method"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100", 
                "1000", 
                "10000"
            ], 
            [
                "'linear'", 
                "'nearest'", 
                "'zero'", 
                "'slinear'", 
                "'quadratic'", 
                "'cubic'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "53ba4880a25d7a65d8bec417088d2ca3afa8e6a6534ed1eb7cf8eefe94f495bd", 
        "warmup_time": -1
    }, 
    "interpolate.Interpolate1d.time_interpolate_eval": {
        "code": "class Interpolate1d:\n    def time_interpolate_eval(self, n_samples, method):\n        \"\"\"Time the evaluation.\"\"\"\n        self.interpolator(self.xp)\n\n    def setup(self, n_samples, method):\n        self.x = np.arange(n_samples)\n        self.y = np.exp(-self.x/3.0)\n        self.interpolator = interpolate.interp1d(self.x, self.y, kind=method)\n        self.xp = np.linspace(self.x[0], self.x[-1], 4*n_samples)", 
        "min_run_count": 2, 
        "name": "interpolate.Interpolate1d.time_interpolate_eval", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "method"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100", 
                "1000", 
                "10000"
            ], 
            [
                "'linear'", 
                "'nearest'", 
                "'zero'", 
                "'slinear'", 
                "'quadratic'", 
                "'cubic'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "3e0c45886b58b68e7ea23068e78aee4f40175e59b2d3ec290f376d1fae95809d", 
        "warmup_time": -1
    }, 
    "interpolate.Interpolate2d.time_interpolate": {
        "code": "class Interpolate2d:\n    def time_interpolate(self, n_samples, method):\n        interpolate.interp2d(self.x, self.y, self.z, kind=method)\n\n    def setup(self, n_samples, method):\n        r_samples = n_samples / 2.\n        self.x = np.arange(-r_samples, r_samples, 0.25)\n        self.y = np.arange(-r_samples, r_samples, 0.25)\n        self.xx, self.yy = np.meshgrid(self.x, self.y)\n        self.z = np.sin(self.xx**2+self.yy**2)", 
        "min_run_count": 2, 
        "name": "interpolate.Interpolate2d.time_interpolate", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "method"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100"
            ], 
            [
                "'linear'", 
                "'cubic'", 
                "'quintic'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "48934ebda129680d6805a76a05748186a57d213fc0f27db8782b2705c6d6c7ec", 
        "warmup_time": -1
    }, 
    "interpolate.Leaks.track_leaks": {
        "code": "class Leaks:\n    def track_leaks(self):\n        set_mem_rlimit()\n    \n        # Setup temp file, make it fit in memory\n        repeats = [2, 5, 10, 50, 200]\n        peak_mems = []\n    \n        for repeat in repeats:\n            code = \"\"\"\n            import numpy as np\n            from scipy.interpolate import griddata\n    \n            def func(x, y):\n                return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2\n    \n            grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]\n            points = np.random.rand(1000, 2)\n            values = func(points[:,0], points[:,1])\n    \n            for t in range(%(repeat)d):\n                for method in ['nearest', 'linear', 'cubic']:\n                    griddata(points, values, (grid_x, grid_y), method=method)\n    \n            \"\"\" % dict(repeat=repeat)\n    \n            _, peak_mem = run_monitored(code)\n            peak_mems.append(peak_mem)\n    \n        corr, p = spearmanr(repeats, peak_mems)\n        if p < 0.05:\n            print(\"*\"*79)\n            print(\"PROBABLE MEMORY LEAK\")\n            print(\"*\"*79)\n        else:\n            print(\"PROBABLY NO MEMORY LEAK\")\n    \n        return max(peak_mems) / min(peak_mems)", 
        "name": "interpolate.Leaks.track_leaks", 
        "param_names": [], 
        "params": [], 
        "timeout": 60.0, 
        "type": "track", 
        "unit": "relative increase with repeats", 
        "version": "660364525468f5ec677c63e82cdf86d50c2f10a4ccbcc4f1f116be695f7c0f50"
    }, 
    "interpolate.Rbf.time_rbf_1d": {
        "code": "class Rbf:\n    def time_rbf_1d(self, n_samples, function):\n        interpolate.Rbf(self.x, self.y, function=function)\n\n    def setup(self, n_samples, function):\n        self.x = np.arange(n_samples)\n        self.y = np.sin(self.x)\n        r_samples = n_samples / 2.\n        self.X = np.arange(-r_samples, r_samples, 0.25)\n        self.Y = np.arange(-r_samples, r_samples, 0.25)\n        self.z = np.exp(-self.X**2-self.Y**2)", 
        "min_run_count": 2, 
        "name": "interpolate.Rbf.time_rbf_1d", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "function"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100"
            ], 
            [
                "'multiquadric'", 
                "'inverse'", 
                "'gaussian'", 
                "'linear'", 
                "'cubic'", 
                "'quintic'", 
                "'thin_plate'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "322c7df9c3945502018241a8354ba06d665f4724576975d7749676e435f50628", 
        "warmup_time": -1
    }, 
    "interpolate.Rbf.time_rbf_2d": {
        "code": "class Rbf:\n    def time_rbf_2d(self, n_samples, function):\n        interpolate.Rbf(self.X, self.Y, self.z, function=function)\n\n    def setup(self, n_samples, function):\n        self.x = np.arange(n_samples)\n        self.y = np.sin(self.x)\n        r_samples = n_samples / 2.\n        self.X = np.arange(-r_samples, r_samples, 0.25)\n        self.Y = np.arange(-r_samples, r_samples, 0.25)\n        self.z = np.exp(-self.X**2-self.Y**2)", 
        "min_run_count": 2, 
        "name": "interpolate.Rbf.time_rbf_2d", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "function"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100"
            ], 
            [
                "'multiquadric'", 
                "'inverse'", 
                "'gaussian'", 
                "'linear'", 
                "'cubic'", 
                "'quintic'", 
                "'thin_plate'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0836465665fd46106764a0b8e45f7701a551aadfc91900cba329fda573193f18", 
        "warmup_time": -1
    }, 
    "interpolate.UnivariateSpline.time_univariate_spline": {
        "code": "class UnivariateSpline:\n    def time_univariate_spline(self, n_samples, degree):\n        interpolate.UnivariateSpline(self.x, self.y, k=degree)\n\n    def setup(self, n_samples, degree):\n        r_samples = n_samples / 2.\n        self.x = np.arange(-r_samples, r_samples, 0.25)\n        self.y = np.exp(-self.x**2) + 0.1 * np.random.randn(*self.x.shape)", 
        "min_run_count": 2, 
        "name": "interpolate.UnivariateSpline.time_univariate_spline", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "degree"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100"
            ], 
            [
                "3", 
                "4", 
                "5"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "f29463d3d509e8f0d4533dce41682ae23c6c047e50f237c9afaac689ccf4df7d", 
        "warmup_time": -1
    }, 
    "io_matlab.MemUsage.track_loadmat": {
        "code": "class MemUsage:\n    def track_loadmat(self, size, compressed):\n        size = int(self.sizes[size])\n    \n        x = np.random.rand(size//8).view(dtype=np.uint8)\n        savemat(self.filename, dict(x=x), do_compression=compressed, oned_as='row')\n        del x\n    \n        code = \"\"\"\n        from scipy.io import loadmat\n        loadmat('%s')\n        \"\"\" % (self.filename,)\n        time, peak_mem = run_monitored(code)\n    \n        return peak_mem / size\n\n    def setup(self, size, compressed):\n        set_mem_rlimit()\n        self.sizes = self._get_sizes()\n        size = int(self.sizes[size])\n    \n        mem_info = get_mem_info()\n        try:\n            mem_available = mem_info['memavailable']\n        except KeyError:\n            mem_available = mem_info['memtotal']\n    \n        max_size = int(mem_available * 0.7)//4\n    \n        if size > max_size:\n            raise NotImplementedError()\n    \n        # Setup temp file\n        f = tempfile.NamedTemporaryFile(delete=False, suffix='.mat')\n        f.close()\n        self.filename = f.name", 
        "name": "io_matlab.MemUsage.track_loadmat", 
        "param_names": [
            "size", 
            "compressed"
        ], 
        "params": [
            [
                "'1M'", 
                "'10M'", 
                "'100M'", 
                "'300M'"
            ], 
            [
                "True", 
                "False"
            ]
        ], 
        "timeout": 240, 
        "type": "track", 
        "unit": "actual/optimal memory usage ratio", 
        "version": "a3de0f2b928a44594543559ae20a75c3b68b8ef0804ee8d76eb5d22cad39dd88"
    }, 
    "io_matlab.MemUsage.track_savemat": {
        "code": "class MemUsage:\n    def track_savemat(self, size, compressed):\n        size = int(self.sizes[size])\n    \n        code = \"\"\"\n        import numpy as np\n        from scipy.io import savemat\n        x = np.random.rand(%d//8).view(dtype=np.uint8)\n        savemat('%s', dict(x=x), do_compression=%r, oned_as='row')\n        \"\"\" % (size, self.filename, compressed)\n        time, peak_mem = run_monitored(code)\n        return peak_mem / size\n\n    def setup(self, size, compressed):\n        set_mem_rlimit()\n        self.sizes = self._get_sizes()\n        size = int(self.sizes[size])\n    \n        mem_info = get_mem_info()\n        try:\n            mem_available = mem_info['memavailable']\n        except KeyError:\n            mem_available = mem_info['memtotal']\n    \n        max_size = int(mem_available * 0.7)//4\n    \n        if size > max_size:\n            raise NotImplementedError()\n    \n        # Setup temp file\n        f = tempfile.NamedTemporaryFile(delete=False, suffix='.mat')\n        f.close()\n        self.filename = f.name", 
        "name": "io_matlab.MemUsage.track_savemat", 
        "param_names": [
            "size", 
            "compressed"
        ], 
        "params": [
            [
                "'1M'", 
                "'10M'", 
                "'100M'", 
                "'300M'"
            ], 
            [
                "True", 
                "False"
            ]
        ], 
        "timeout": 240, 
        "type": "track", 
        "unit": "actual/optimal memory usage ratio", 
        "version": "457047076d11d25f1a3deee28e9af72616a90b5d6e383857226f869182bd8547"
    }, 
    "io_matlab.StructArr.time_loadmat": {
        "code": "class StructArr:\n    def time_loadmat(self, nvfs, compression):\n        loadmat(self.str_io)\n\n    def setup(self, nvfs, compression):\n        n_vars, n_fields, n_structs = nvfs\n    \n        self.var_dict = StructArr.make_structarr(n_vars, n_fields, n_structs)\n        self.str_io = BytesIO()\n    \n        savemat(self.str_io, self.var_dict, do_compression=compression)", 
        "min_run_count": 2, 
        "name": "io_matlab.StructArr.time_loadmat", 
        "number": 0, 
        "param_names": [
            "(vars, fields, structs)", 
            "compression"
        ], 
        "params": [
            [
                "(10, 10, 20)", 
                "(20, 20, 40)", 
                "(30, 30, 50)"
            ], 
            [
                "False", 
                "True"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "eaa1ea6c664b345fc8dd0a51ff7eedc973ed011300a9b2d3dedeec8cc61c2555", 
        "warmup_time": -1
    }, 
    "io_matlab.StructArr.time_savemat": {
        "code": "class StructArr:\n    def time_savemat(self, nvfs, compression):\n        savemat(self.str_io, self.var_dict, do_compression=compression)\n\n    def setup(self, nvfs, compression):\n        n_vars, n_fields, n_structs = nvfs\n    \n        self.var_dict = StructArr.make_structarr(n_vars, n_fields, n_structs)\n        self.str_io = BytesIO()\n    \n        savemat(self.str_io, self.var_dict, do_compression=compression)", 
        "min_run_count": 2, 
        "name": "io_matlab.StructArr.time_savemat", 
        "number": 0, 
        "param_names": [
            "(vars, fields, structs)", 
            "compression"
        ], 
        "params": [
            [
                "(10, 10, 20)", 
                "(20, 20, 40)", 
                "(30, 30, 50)"
            ], 
            [
                "False", 
                "True"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8a4f85a8ff747a27983a799694aabf4332d11c7f5adb4b4a7db60a6b88ee538a", 
        "warmup_time": -1
    }, 
    "linalg.Bench.time_det": {
        "code": "class Bench:\n    def time_det(self, size, contig, module):\n        if module == 'numpy':\n            nl.det(self.a)\n        else:\n            sl.det(self.a)\n\n    def setup(self, size, contig, module):\n        a = random([size,size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i,i] = 10*(.1+a[i,i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", 
        "min_run_count": 2, 
        "name": "linalg.Bench.time_det", 
        "number": 0, 
        "param_names": [
            "size", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "20", 
                "100", 
                "500", 
                "1000"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "87e530ee50eb6b6c06c7a8abe51c2168e133d5cbd486f4c1c2b9cedc5a078325", 
        "warmup_time": -1
    }, 
    "linalg.Bench.time_eigvals": {
        "code": "class Bench:\n    def time_eigvals(self, size, contig, module):\n        if module == 'numpy':\n            nl.eigvals(self.a)\n        else:\n            sl.eigvals(self.a)\n\n    def setup(self, size, contig, module):\n        a = random([size,size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i,i] = 10*(.1+a[i,i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", 
        "min_run_count": 2, 
        "name": "linalg.Bench.time_eigvals", 
        "number": 0, 
        "param_names": [
            "size", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "20", 
                "100", 
                "500", 
                "1000"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "9d68d3a6b473df9bdda3d3fd25c7f9aeea7d5cee869eec730fb2a2bcd1dfb907", 
        "warmup_time": -1
    }, 
    "linalg.Bench.time_inv": {
        "code": "class Bench:\n    def time_inv(self, size, contig, module):\n        if module == 'numpy':\n            nl.inv(self.a)\n        else:\n            sl.inv(self.a)\n\n    def setup(self, size, contig, module):\n        a = random([size,size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i,i] = 10*(.1+a[i,i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", 
        "min_run_count": 2, 
        "name": "linalg.Bench.time_inv", 
        "number": 0, 
        "param_names": [
            "size", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "20", 
                "100", 
                "500", 
                "1000"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "20beee193c84a5713da9749246a7c40ef21590186c35ed00a4fe854cce9e153b", 
        "warmup_time": -1
    }, 
    "linalg.Bench.time_solve": {
        "code": "class Bench:\n    def time_solve(self, size, contig, module):\n        if module == 'numpy':\n            nl.solve(self.a, self.b)\n        else:\n            sl.solve(self.a, self.b)\n\n    def setup(self, size, contig, module):\n        a = random([size,size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i,i] = 10*(.1+a[i,i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", 
        "min_run_count": 2, 
        "name": "linalg.Bench.time_solve", 
        "number": 0, 
        "param_names": [
            "size", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "20", 
                "100", 
                "500", 
                "1000"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "1fe788070f1c9132cbe78a47fdb4cce58266427fc636d2aa9450e3c7d92c644c", 
        "warmup_time": -1
    }, 
    "linalg.Bench.time_svd": {
        "code": "class Bench:\n    def time_svd(self, size, contig, module):\n        if module == 'numpy':\n            nl.svd(self.a)\n        else:\n            sl.svd(self.a)\n\n    def setup(self, size, contig, module):\n        a = random([size,size])\n        # larger diagonal ensures non-singularity:\n        for i in range(size):\n            a[i,i] = 10*(.1+a[i,i])\n        b = random([size])\n    \n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n    \n        self.a = a\n        self.b = b", 
        "min_run_count": 2, 
        "name": "linalg.Bench.time_svd", 
        "number": 0, 
        "param_names": [
            "size", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "20", 
                "100", 
                "500", 
                "1000"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0ccbda456d096e459d4a6eefc6c674a815179e215f83931a81cfa8c18e39d6e3", 
        "warmup_time": -1
    }, 
    "linalg.Lstsq.time_lstsq": {
        "code": "class Lstsq:\n    def time_lstsq(self, dtype, size, lapack_driver):\n        if lapack_driver == 'numpy':\n            np.linalg.lstsq(self.A, self.b,\n                            rcond=np.finfo(self.A.dtype).eps * 100)\n        else:\n            sl.lstsq(self.A, self.b, cond=None, overwrite_a=False,\n                     overwrite_b=False, check_finite=False,\n                     lapack_driver=lapack_driver)\n\n    def setup(self, dtype, size, lapack_driver):\n        np.random.seed(1234)\n        n = math.ceil(2./3. * size)\n        k = math.ceil(1./2. * size)\n        m = size\n    \n        if dtype is np.complex128:\n            A = ((10 * np.random.rand(m,k) - 5) +\n                 1j*(10 * np.random.rand(m,k) - 5))\n            temp = ((10 * np.random.rand(k,n) - 5) +\n                    1j*(10 * np.random.rand(k,n) - 5))\n            b = ((10 * np.random.rand(m,1) - 5) +\n                 1j*(10 * np.random.rand(m,1) - 5))\n        else:\n            A = (10 * np.random.rand(m,k) - 5)\n            temp = 10 * np.random.rand(k,n) - 5\n            b = 10 * np.random.rand(m,1) - 5\n    \n        self.A = A.dot(temp)\n        self.b = b", 
        "min_run_count": 2, 
        "name": "linalg.Lstsq.time_lstsq", 
        "number": 0, 
        "param_names": [
            "dtype", 
            "size", 
            "driver"
        ], 
        "params": [
            [
                "<type 'numpy.float64'>", 
                "<type 'numpy.complex128'>"
            ], 
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'gelss'", 
                "'gelsy'", 
                "'gelsd'", 
                "'numpy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "15ee0be14a0a597c7d1c9a3dab2c39e15c8ac623484410ffefa406bf6b596ebe", 
        "warmup_time": -1
    }, 
    "linalg.Norm.time_1_norm": {
        "code": "class Norm:\n    def time_1_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a, ord=1)\n        else:\n            sl.norm(self.a, ord=1)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a", 
        "min_run_count": 2, 
        "name": "linalg.Norm.time_1_norm", 
        "number": 0, 
        "param_names": [
            "shape", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "(20, 20)", 
                "(100, 100)", 
                "(1000, 1000)", 
                "(20, 1000)", 
                "(1000, 20)"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0c4e469d4304940ea54e1e81648836218da8c130601351fcd645b5d0856aad52", 
        "warmup_time": -1
    }, 
    "linalg.Norm.time_frobenius_norm": {
        "code": "class Norm:\n    def time_frobenius_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a)\n        else:\n            sl.norm(self.a)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a", 
        "min_run_count": 2, 
        "name": "linalg.Norm.time_frobenius_norm", 
        "number": 0, 
        "param_names": [
            "shape", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "(20, 20)", 
                "(100, 100)", 
                "(1000, 1000)", 
                "(20, 1000)", 
                "(1000, 20)"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8fe6813e0aaaefc14b8423df9052a9ae584c655d64d2aa3f640bccf491f5023d", 
        "warmup_time": -1
    }, 
    "linalg.Norm.time_inf_norm": {
        "code": "class Norm:\n    def time_inf_norm(self, size, contig, module):\n        if module == 'numpy':\n            nl.norm(self.a, ord=np.inf)\n        else:\n            sl.norm(self.a, ord=np.inf)\n\n    def setup(self, shape, contig, module):\n        a = np.random.randn(*shape)\n        if contig != 'contig':\n            a = a[-1::-1,-1::-1]  # turn into a non-contiguous array\n            assert_(not a.flags['CONTIGUOUS'])\n        self.a = a", 
        "min_run_count": 2, 
        "name": "linalg.Norm.time_inf_norm", 
        "number": 0, 
        "param_names": [
            "shape", 
            "contiguous", 
            "module"
        ], 
        "params": [
            [
                "(20, 20)", 
                "(100, 100)", 
                "(1000, 1000)", 
                "(20, 1000)", 
                "(1000, 20)"
            ], 
            [
                "'contig'", 
                "'nocont'"
            ], 
            [
                "'numpy'", 
                "'scipy'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "eeebd84b29c3213e8701161fb693d8ccf1b0a3ce1571b7056a2375d860a9f379", 
        "warmup_time": -1
    }, 
    "linalg_solve_toeplitz.SolveToeplitz.time_solve_toeplitz": {
        "code": "class SolveToeplitz:\n    def time_solve_toeplitz(self, dtype, n, soltype):\n        if soltype == 'toeplitz':\n            scipy.linalg.solve_toeplitz((self.c, self.r), self.y)\n        else:\n            scipy.linalg.solve(self.T, self.y)\n\n    def setup(self, dtype, n, soltype):\n        random = np.random.RandomState(1234)\n    \n        dtype = np.dtype(dtype)\n    \n        # Sample a random Toeplitz matrix representation and rhs.\n        c = random.randn(n)\n        r = random.randn(n)\n        y = random.randn(n)\n        if dtype == np.complex128:\n            c = c + 1j*random.rand(n)\n            r = r + 1j*random.rand(n)\n            y = y + 1j*random.rand(n)\n    \n        self.c = c\n        self.r = r\n        self.y = y\n        self.T = scipy.linalg.toeplitz(c, r=r)", 
        "min_run_count": 2, 
        "name": "linalg_solve_toeplitz.SolveToeplitz.time_solve_toeplitz", 
        "number": 0, 
        "param_names": [
            "dtype", 
            "n", 
            "solver"
        ], 
        "params": [
            [
                "'float64'", 
                "'complex128'"
            ], 
            [
                "100", 
                "300", 
                "1000"
            ], 
            [
                "'toeplitz'", 
                "'generic'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "d5d6bb8933b458885e968d871d860965a2af33720ca7a4872dafe7b9db2eb5c3", 
        "warmup_time": -1
    }, 
    "linalg_sqrtm.Sqrtm.time_sqrtm": {
        "code": "class Sqrtm:\n    def time_sqrtm(self, dtype, n, blocksize):\n        scipy.linalg.sqrtm(self.A, disp=False, blocksize=blocksize)\n\n    def setup(self, dtype, n, blocksize):\n        n = int(n)\n        dtype = np.dtype(dtype)\n        blocksize = int(blocksize)\n        A = np.random.rand(n, n)\n        if dtype == np.complex128:\n            A = A + 1j*np.random.rand(n, n)\n        self.A = A\n    \n        if blocksize > n:\n            raise NotImplementedError()", 
        "min_run_count": 2, 
        "name": "linalg_sqrtm.Sqrtm.time_sqrtm", 
        "number": 0, 
        "param_names": [
            "dtype", 
            "n", 
            "blocksize"
        ], 
        "params": [
            [
                "'float64'", 
                "'complex128'"
            ], 
            [
                "64", 
                "256"
            ], 
            [
                "32", 
                "64", 
                "256"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "359ff21f2b4f63f08772e0e19eef1758190d58abd549c8b5b6d8b784100b9cb0", 
        "warmup_time": -1
    }, 
    "optimize.BenchGlobal.track_all": {
        "code": "class BenchGlobal:\n    def track_all(self, name, ret_value, solver):\n        if name in self.results and solver in self.results[name]:\n            # have we done the function, and done the solver?\n            # if so, then just return the ret_value\n            av_results = self.results[name]\n            if ret_value == 'success%':\n                return 100 * av_results[solver]['nsuccess'] / av_results[solver]['ntrials']\n            elif ret_value == '<nfev>':\n                return av_results[solver]['mean_nfev']\n            else:\n                raise ValueError()\n    \n        klass = self._functions[name]\n        f = klass()\n        try:\n            b = _BenchOptimizers.from_funcobj(name, f)\n            with np.errstate(all='ignore'):\n                b.bench_run_global(methods=[solver],\n                                   numtrials=self.numtrials)\n    \n            av_results = b.average_results()\n    \n            if name not in self.results:\n                self.results[name] = {}\n            self.results[name][solver] = av_results[solver]\n    \n            if ret_value == 'success%':\n                return 100 * av_results[solver]['nsuccess'] / av_results[solver]['ntrials']\n            elif ret_value == '<nfev>':\n                return av_results[solver]['mean_nfev']\n            else:\n                raise ValueError()\n        except:\n            print(\"\".join(traceback.format_exc()))\n            self.results[name] = \"\".join(traceback.format_exc())\n\n    def setup(self, name, ret_value, solver):\n        if not self.enabled:\n            print(\"BenchGlobal.track_all not enabled --- export SCIPY_XSLOW=slow to enable,\\n\"\n                  \"'slow' iterations of each benchmark will be run.\\n\"\n                  \"Note that it can take several hours to run; intermediate output\\n\"\n                  \"can be found under benchmarks/global-bench-results.json\\n\"\n                  \"You can specify functions to benchmark via SCIPY_GLOBAL_BENCH=AMGM,Adjiman,...\")\n            raise NotImplementedError()\n        # load json backing file\n        with open(self.dump_fn, 'r') as f:\n            self.results = json.load(f)\n\n    def setup_cache(self):\n        if not self.enabled:\n            return\n    \n        # create the logfile to start with\n        with open(self.dump_fn, 'w') as f:\n            json.dump({}, f, indent=2)", 
        "name": "optimize.BenchGlobal.track_all", 
        "param_names": [
            "test function", 
            "result type", 
            "solver"
        ], 
        "params": [
            [
                "'AMGM'"
            ], 
            [
                "'success%'", 
                "'<nfev>'"
            ], 
            [
                "'DE'", 
                "'basinh.'"
            ]
        ], 
        "setup_cache_key": "/mnt/c/Users/treddy/github_projects/scipy/benchmarks/benchmarks/optimize.py:490", 
        "timeout": 300, 
        "type": "track", 
        "unit": "unit", 
        "version": "a35d26f0dbe2545c9ace6bc3f74c5a49ea4864e4d58ee9b8f282ae095c518bf3"
    }, 
    "optimize.BenchLeastSquares.track_all": {
        "code": "class BenchLeastSquares:\n    def track_all(self, problem_name, result_type):\n        problem = self.problems[problem_name]\n    \n        if problem.lb is not None or problem.ub is not None:\n            raise NotImplementedError\n    \n        ftol = 1e-5\n    \n        if result_type == 'average time':\n            n_runs = 10\n            t0 = time.time()\n            for _ in range(n_runs):\n                leastsq(problem.fun, problem.x0, Dfun=problem.jac, ftol=ftol,\n                        full_output=True)\n            return (time.time() - t0) / n_runs\n    \n        x, cov_x, info, message, ier = leastsq(\n            problem.fun, problem.x0, Dfun=problem.jac,\n            ftol=ftol, full_output=True\n        )\n        if result_type == 'nfev':\n            return info['nfev']\n        elif result_type == 'success':\n            return int(problem.check_answer(x, ftol))\n        else:\n            raise NotImplementedError", 
        "name": "optimize.BenchLeastSquares.track_all", 
        "param_names": [
            "problem", 
            "result type"
        ], 
        "params": [
            [
                "'AlphaPineneDirect'", 
                "'ChebyshevQuadrature'", 
                "'CoatingThickness'", 
                "'EnzymeReaction'", 
                "'ExponentialFitting'", 
                "'GaussianFitting'", 
                "'ThermistorResistance'"
            ], 
            [
                "'average time'", 
                "'nfev'", 
                "'success'"
            ]
        ], 
        "timeout": 60.0, 
        "type": "track", 
        "unit": "unit", 
        "version": "f38fbe672c2954249e521c5aa92737c6659f885c52e0ed5fa863c171f56bb902"
    }, 
    "optimize.BenchSmoothUnbounded.track_all": {
        "code": "class BenchSmoothUnbounded:\n    def track_all(self, func_name, method_name, ret_val):\n        return self.result\n\n    def setup(self, func_name, method_name, ret_val):\n        b = getattr(self, 'run_' + func_name)(methods=[method_name])\n        r = b.average_results().get(method_name)\n        if r is None:\n            raise NotImplementedError()\n        self.result = getattr(r, ret_val)", 
        "name": "optimize.BenchSmoothUnbounded.track_all", 
        "param_names": [
            "test function", 
            "solver", 
            "result type"
        ], 
        "params": [
            [
                "'rosenbrock'", 
                "'rosenbrock_tight'", 
                "'simple_quadratic'", 
                "'asymmetric_quadratic'", 
                "'sin_1d'", 
                "'booth'", 
                "'beale'", 
                "'LJ'"
            ], 
            [
                "'COBYLA'", 
                "'Powell'", 
                "'L-BFGS-B'", 
                "'BFGS'", 
                "'CG'", 
                "'TNC'", 
                "'SLSQP'", 
                "'Newton-CG'", 
                "'dogleg'", 
                "'trust-ncg'", 
                "'trust-exact'", 
                "'trust-krylov'"
            ], 
            [
                "'mean_nfev'", 
                "'mean_time'"
            ]
        ], 
        "timeout": 60.0, 
        "type": "track", 
        "unit": "unit", 
        "version": "470a193366611f84efefb220d095286dbc18dc8501b63d8e703aad41a1b0b32f"
    }, 
    "optimize_linprog.KleeMinty.time_klee_minty": {
        "code": "class KleeMinty:\n    def time_klee_minty(self, meth, dims):\n        linprog(c=self.c, A_ub=self.A_ub, b_ub=self.b_ub, method=self.meth)\n\n    def setup(self, meth, dims):\n        self.c, self.A_ub, self.b_ub = klee_minty(dims)\n        self.meth = meth", 
        "min_run_count": 2, 
        "name": "optimize_linprog.KleeMinty.time_klee_minty", 
        "number": 0, 
        "param_names": [
            "method", 
            "dimensions"
        ], 
        "params": [
            [
                "'simplex'", 
                "'interior-point'"
            ], 
            [
                "3", 
                "6", 
                "9"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "9e8b6fda8d178ed24cfc3efe9dbb505dcbd7a138d2178d51a79a042094e5471e", 
        "warmup_time": -1
    }, 
    "optimize_linprog.LpGen.time_lpgen": {
        "code": "class LpGen:\n    def time_lpgen(self, meth, m, n):\n        with suppress_warnings() as sup:\n            sup.filter(RuntimeWarning, \"scipy.linalg.solve\\nIll-conditioned\")\n            linprog(c=self.c, A_ub=self.A, b_ub=self.b, method=self.meth)\n\n    def setup(self, meth, m, n):\n        self.A, self.b, self.c = lpgen_2d(m, n)\n        self.meth = meth", 
        "min_run_count": 2, 
        "name": "optimize_linprog.LpGen.time_lpgen", 
        "number": 0, 
        "param_names": [
            "method", 
            "m", 
            "n"
        ], 
        "params": [
            [
                "'simplex'", 
                "'interior-point'"
            ], 
            [
                "20", 
                "40", 
                "60", 
                "80"
            ], 
            [
                "20", 
                "40", 
                "60", 
                "80"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "d0369f5bda3c13612d0c886e2cee30d2d4d2d2364623b1b47e56d352af8c69a0", 
        "warmup_time": -1
    }, 
    "optimize_linprog.Netlib.time_netlib": {
        "code": "class Netlib:\n    def time_netlib(self, meth, prob):\n        res = linprog(c=self.c,\n                      A_ub=self.A_ub,\n                      b_ub=self.b_ub,\n                      A_eq=self.A_eq,\n                      b_eq=self.b_eq,\n                      bounds=self.bounds,\n                      method=meth)\n        np.testing.assert_allclose(self.obj, res.fun)\n\n    def setup(self, meth, prob):\n        dir_path = os.path.dirname(os.path.realpath(__file__))\n        data = np.load(dir_path + \"/linprog_benchmark_files/\" + prob + \".npz\")\n        self.c = data[\"c\"]\n        self.A_eq = data[\"A_eq\"]\n        self.A_ub = data[\"A_ub\"]\n        self.b_ub = data[\"b_ub\"]\n        self.b_eq = data[\"b_eq\"]\n        self.bounds = (0, None)\n        self.obj = float(data[\"obj\"].flatten()[0])", 
        "min_run_count": 2, 
        "name": "optimize_linprog.Netlib.time_netlib", 
        "number": 0, 
        "param_names": [
            "method", 
            "problems"
        ], 
        "params": [
            [
                "'simplex'", 
                "'interior-point'"
            ], 
            [
                "'AFIRO'", 
                "'BLEND'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "6f8ef73b4047ccc8d0b5bed95869e4664459189329013995f81b2176a91494b6", 
        "warmup_time": -1
    }, 
    "optimize_zeros.Zeros.time_zeros": {
        "code": "class Zeros:\n    def time_zeros(self, func, meth):\n        self.meth(self.func, self.a, self.b)\n\n    def setup(self, func, meth):\n        self.a = .5\n        self.b = sqrt(3)\n    \n        self.func = functions[fstrings.index(func)]\n        self.meth = methods[mstrings.index(meth)]", 
        "min_run_count": 2, 
        "name": "optimize_zeros.Zeros.time_zeros", 
        "number": 0, 
        "param_names": [
            "test function", 
            "solver"
        ], 
        "params": [
            [
                "'f2'", 
                "'f3'", 
                "'f4'", 
                "'f5'", 
                "'f6'"
            ], 
            [
                "'cc.bisect'", 
                "'cc.ridder'", 
                "'cc.brenth'", 
                "'cc.brentq'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "e70efd439f371e19964039ab8d954254811da7754783c41cc71759ad0f59e24a", 
        "warmup_time": -1
    }, 
    "signal.CalculateWindowedFFT.time_coherence": {
        "code": "class CalculateWindowedFFT:\n    def time_coherence(self):\n        signal.coherence(self.x, self.y)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "signal.CalculateWindowedFFT.time_coherence", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "264b03ada7f4710c1fac42e5f704c83e4456ffe9d30fd2a23be1511df8115022", 
        "warmup_time": -1
    }, 
    "signal.CalculateWindowedFFT.time_csd": {
        "code": "class CalculateWindowedFFT:\n    def time_csd(self):\n        signal.csd(self.x, self.y)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "signal.CalculateWindowedFFT.time_csd", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "aec73d92d2e6342b381c748a3af200838c3b8d2916207ffe20c42b322c6dada8", 
        "warmup_time": -1
    }, 
    "signal.CalculateWindowedFFT.time_periodogram": {
        "code": "class CalculateWindowedFFT:\n    def time_periodogram(self):\n        signal.periodogram(self.x)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "signal.CalculateWindowedFFT.time_periodogram", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "e9722853e1c16a747daaa48d2f6f5d92ab20479788cec7957a4842cb0ff65c3c", 
        "warmup_time": -1
    }, 
    "signal.CalculateWindowedFFT.time_spectrogram": {
        "code": "class CalculateWindowedFFT:\n    def time_spectrogram(self):\n        signal.spectrogram(self.x)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "signal.CalculateWindowedFFT.time_spectrogram", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "ad8b14343bc83e0ac6baabb34c10edf2b8ff25adbf2c5f0b54365f8223ab35ca", 
        "warmup_time": -1
    }, 
    "signal.CalculateWindowedFFT.time_welch": {
        "code": "class CalculateWindowedFFT:\n    def time_welch(self):\n        signal.welch(self.x)\n\n    def setup(self):\n        np.random.seed(5678)\n        # Create some long arrays for computation\n        x = np.random.randn(2**20)\n        y = np.random.randn(2**20)\n        self.x = x\n        self.y = y", 
        "min_run_count": 2, 
        "name": "signal.CalculateWindowedFFT.time_welch", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "a250d739676f9ee24c1c85850424941a65cbac0c01d89b9d08942043e805b679", 
        "warmup_time": -1
    }, 
    "signal.Convolve.time_convolve": {
        "code": "class Convolve:\n    def time_convolve(self, mode):\n        for a, b in self.pairs:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.convolve(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs.append((a, b))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.Convolve.time_convolve", 
        "number": 0, 
        "param_names": [
            "mode"
        ], 
        "params": [
            [
                "'full'", 
                "'valid'", 
                "'same'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "4d428c57cab557436ab187fa8845562c5c1b7318c0644bb9daa2a715d354472d", 
        "warmup_time": -1
    }, 
    "signal.Convolve.time_correlate": {
        "code": "class Convolve:\n    def time_correlate(self, mode):\n        for a, b in self.pairs:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.correlate(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs.append((a, b))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.Convolve.time_correlate", 
        "number": 0, 
        "param_names": [
            "mode"
        ], 
        "params": [
            [
                "'full'", 
                "'valid'", 
                "'same'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "259601b5ac27d86532795069fcb8229f027f85a58ccd2a0608097ed6954386e9", 
        "warmup_time": -1
    }, 
    "signal.Convolve2D.time_convolve2d": {
        "code": "class Convolve2D:\n    def time_convolve2d(self, mode, boundary):\n        for a, b in self.pairs:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.convolve2d(a, b, mode=mode, boundary=boundary)\n\n    def setup(self, mode, boundary):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, na, mb, nb in product((1, 2, 8, 13, 30), repeat=4):\n            a = np.random.randn(ma, na)\n            b = np.random.randn(mb, nb)\n            pairs.append((a, b))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.Convolve2D.time_convolve2d", 
        "number": 0, 
        "param_names": [
            "mode", 
            "boundary"
        ], 
        "params": [
            [
                "'full'", 
                "'valid'", 
                "'same'"
            ], 
            [
                "'fill'", 
                "'wrap'", 
                "'symm'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0b211950d888b5e5c3f249f5d0dddb21d201c3561be564cfddb2500c44b858c7", 
        "warmup_time": -1
    }, 
    "signal.Convolve2D.time_correlate2d": {
        "code": "class Convolve2D:\n    def time_correlate2d(self, mode, boundary):\n        for a, b in self.pairs:\n            if mode == 'valid':\n                if b.shape[0] > a.shape[0] or b.shape[1] > a.shape[1]:\n                    continue\n            signal.correlate2d(a, b, mode=mode, boundary=boundary)\n\n    def setup(self, mode, boundary):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, na, mb, nb in product((1, 2, 8, 13, 30), repeat=4):\n            a = np.random.randn(ma, na)\n            b = np.random.randn(mb, nb)\n            pairs.append((a, b))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.Convolve2D.time_correlate2d", 
        "number": 0, 
        "param_names": [
            "mode", 
            "boundary"
        ], 
        "params": [
            [
                "'full'", 
                "'valid'", 
                "'same'"
            ], 
            [
                "'fill'", 
                "'wrap'", 
                "'symm'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "f619afe7edabf0832fbe0144f41fa0b9396288721ed01a1899532586875e9207", 
        "warmup_time": -1
    }, 
    "signal.FFTConvolve.time_convolve2d": {
        "code": "class FFTConvolve:\n    def time_convolve2d(self, mode):\n        for a, b in self.pairs:\n            if b.shape[0] > a.shape[0]:\n                continue\n            signal.fftconvolve(a, b, mode=mode)\n\n    def setup(self, mode):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = np.random.randn(ma)\n            b = np.random.randn(nb)\n            pairs.append((a, b))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.FFTConvolve.time_convolve2d", 
        "number": 0, 
        "param_names": [
            "mode"
        ], 
        "params": [
            [
                "'full'", 
                "'valid'", 
                "'same'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "47d8eff33e97c1584892b3d932c85fef01e906ad74561ff5ebe26749d50a11fb", 
        "warmup_time": -1
    }, 
    "signal.LTI.time_bode": {
        "code": "class LTI:\n    def time_bode(self):\n        signal.bode(self.system)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", 
        "min_run_count": 2, 
        "name": "signal.LTI.time_bode", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "9b6900694dcd1678ace232e739006f5edb8fd1ab439b2641c656a52a6a3570a5", 
        "warmup_time": -1
    }, 
    "signal.LTI.time_impulse": {
        "code": "class LTI:\n    def time_impulse(self):\n        signal.impulse(self.system, T=self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", 
        "min_run_count": 2, 
        "name": "signal.LTI.time_impulse", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "36ed9a1159c7a7896d49780e31bf765fedd30ff0e5170d6f5a90d31286ffdd04", 
        "warmup_time": -1
    }, 
    "signal.LTI.time_lsim": {
        "code": "class LTI:\n    def time_lsim(self):\n        signal.lsim(self.system, self.u, self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", 
        "min_run_count": 2, 
        "name": "signal.LTI.time_lsim", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "ab2f127be1b0ae823db19367021a5a82ca4d3f9b41c29574f98efb3a4a9a48cc", 
        "warmup_time": -1
    }, 
    "signal.LTI.time_lsim2": {
        "code": "class LTI:\n    def time_lsim2(self):\n        signal.lsim2(self.system, self.u, self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", 
        "min_run_count": 2, 
        "name": "signal.LTI.time_lsim2", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "5d54047fba8c4fd772104b076d52ba13045b21326e50ea9124871ff3a3924b6e", 
        "warmup_time": -1
    }, 
    "signal.LTI.time_step": {
        "code": "class LTI:\n    def time_step(self):\n        signal.step(self.system, T=self.t)\n\n    def setup(self):\n        self.system = signal.lti(1.0, [1, 0, 1])\n        self.t = np.arange(0, 100, 0.5)\n        self.u = np.sin(2 * self.t)", 
        "min_run_count": 2, 
        "name": "signal.LTI.time_step", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "02de19e2a7d49a4b5349af8a4765271980b219a4c890120b26195f0cae2578c4", 
        "warmup_time": -1
    }, 
    "signal.Upfirdn1D.time_upfirdn1d": {
        "code": "class Upfirdn1D:\n    def time_upfirdn1d(self, up, down):\n        for h, x in self.pairs:\n            signal.upfirdn(h, x, up=up, down=down)\n\n    def setup(self, up, down):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for nfilt in [8, ]:\n            for n in [32, 128, 512, 2048]:\n                    h = np.random.randn(nfilt)\n                    x = np.random.randn(n)\n                    pairs.append((h, x))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.Upfirdn1D.time_upfirdn1d", 
        "number": 0, 
        "param_names": [
            "up", 
            "down"
        ], 
        "params": [
            [
                "1", 
                "4"
            ], 
            [
                "1", 
                "4"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0bf1510d17f1a52aa2307eecf490dcb4330a3334d02769e042ab4c7d44eb5eea", 
        "warmup_time": -1
    }, 
    "signal.Upfirdn2D.time_upfirdn2d": {
        "code": "class Upfirdn2D:\n    def time_upfirdn2d(self, up, down, axis):\n        for h, x in self.pairs:\n            signal.upfirdn(h, x, up=up, down=down, axis=axis)\n\n    def setup(self, up, down, axis):\n        np.random.seed(1234)\n        # sample a bunch of pairs of 2d arrays\n        pairs = []\n        for nfilt in [8, ]:\n            for n in [32, 128, 512]:\n                    h = np.random.randn(nfilt)\n                    x = np.random.randn(n, n)\n                    pairs.append((h, x))\n        self.pairs = pairs", 
        "min_run_count": 2, 
        "name": "signal.Upfirdn2D.time_upfirdn2d", 
        "number": 0, 
        "param_names": [
            "up", 
            "down", 
            "axis"
        ], 
        "params": [
            [
                "1", 
                "4"
            ], 
            [
                "1", 
                "4"
            ], 
            [
                "0", 
                "-1"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "12387e5dd3147844ab7e862c5a61413162ba0207696c72e9a0dafafddcb1aee3", 
        "warmup_time": -1
    }, 
    "signal_filtering.Decimate.time_decimate": {
        "code": "class Decimate:\n    def time_decimate(self, q, ftype, zero_phase):\n        decimate(self.sig, q, ftype=ftype, zero_phase=zero_phase)\n\n    def setup(self, q, ftype, zero_phase):\n        np.random.seed(123456)\n        sample_rate = 10000.\n        t = np.arange(int(1e6), dtype=np.float64) / sample_rate\n        self.sig = np.sin(2*np.pi*500*t) + 0.3 * np.sin(2*np.pi*4e3*t)", 
        "min_run_count": 2, 
        "name": "signal_filtering.Decimate.time_decimate", 
        "number": 0, 
        "param_names": [
            "q", 
            "ftype", 
            "zero_phase"
        ], 
        "params": [
            [
                "2", 
                "10", 
                "30"
            ], 
            [
                "'iir'", 
                "'fir'"
            ], 
            [
                "True", 
                "False"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "aae23358cbe3088f5e199c70a09eec3957561c00aa278ce63bace7052f266e3f", 
        "warmup_time": -1
    }, 
    "signal_filtering.Lfilter.time_lfilter": {
        "code": "class Lfilter:\n    def time_lfilter(self, n_samples, numtaps):\n        lfilter(self.coeff, 1.0, self.sig)\n\n    def setup(self, n_samples, numtaps):\n        np.random.seed(125678)\n        sample_rate = 25000.\n        t = np.arange(n_samples, dtype=np.float64) / sample_rate\n        nyq_rate = sample_rate / 2.\n        cutoff_hz = 3000.0\n        self.sig = np.sin(2*np.pi*500*t) + 0.3 * np.sin(2*np.pi*11e3*t)\n        self.coeff = firwin(numtaps, cutoff_hz/nyq_rate)", 
        "min_run_count": 2, 
        "name": "signal_filtering.Lfilter.time_lfilter", 
        "number": 0, 
        "param_names": [
            "n_samples", 
            "numtaps"
        ], 
        "params": [
            [
                "1000.0", 
                "50000.0", 
                "1000000.0"
            ], 
            [
                "9", 
                "23", 
                "51"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "d30c400692d02cd1bbe665e3146724b8d0c3ba0b274d9816d543808508aecd6e", 
        "warmup_time": -1
    }, 
    "sparse.Arithmetic.time_arithmetic": {
        "code": "class Arithmetic:\n    def time_arithmetic(self, format, XY, op):\n        self.fn(self.y)\n\n    def setup(self, format, XY, op):\n        matrices = dict(A=poisson2d(250, format=format),\n                        B=poisson2d(250, format=format)**2)\n    \n        x = matrices[XY[0]]\n        self.y = matrices[XY[1]]\n        self.fn = getattr(x, op)\n        self.fn(self.y)  # warmup", 
        "min_run_count": 2, 
        "name": "sparse.Arithmetic.time_arithmetic", 
        "number": 0, 
        "param_names": [
            "format", 
            "XY", 
            "op"
        ], 
        "params": [
            [
                "'csr'"
            ], 
            [
                "'AA'", 
                "'AB'", 
                "'BA'", 
                "'BB'"
            ], 
            [
                "'__add__'", 
                "'__sub__'", 
                "'multiply'", 
                "'__mul__'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "83450868d03ffee8f8a2ee6f9f4232ba297f343516d53597fa4b8d544e8700ab", 
        "warmup_time": -1
    }, 
    "sparse.Construction.time_construction": {
        "code": "class Construction:\n    def time_construction(self, name, format):\n        T = self.cls(self.A.shape)\n        for i, j, v in zip(self.A.row, self.A.col, self.A.data):\n            T[i, j] = v\n\n    def setup(self, name, format):\n        if name == 'Empty':\n            self.A = coo_matrix((10000, 10000))\n        elif name == 'Identity':\n            self.A = sparse.eye(10000, format='coo')\n        else:\n            self.A = poisson2d(100, format='coo')\n    \n        formats = {'lil': lil_matrix, 'dok': dok_matrix}\n        self.cls = formats[format]", 
        "min_run_count": 2, 
        "name": "sparse.Construction.time_construction", 
        "number": 0, 
        "param_names": [
            "matrix", 
            "format"
        ], 
        "params": [
            [
                "'Empty'", 
                "'Identity'", 
                "'Poisson5pt'"
            ], 
            [
                "'lil'", 
                "'dok'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "4051443d954b347f4100b6b10b48436673e8432d95dfcbe0a104249d96a3174f", 
        "warmup_time": -1
    }, 
    "sparse.Conversion.time_conversion": {
        "code": "class Conversion:\n    def time_conversion(self, fromfmt, tofmt):\n        self.fn()\n\n    def setup(self, fromfmt, tofmt):\n        base = poisson2d(100, format=fromfmt)\n    \n        try:\n            self.fn = getattr(base, 'to' + tofmt)\n        except:\n            def fn():\n                raise RuntimeError()\n            self.fn = fn", 
        "min_run_count": 2, 
        "name": "sparse.Conversion.time_conversion", 
        "number": 0, 
        "param_names": [
            "from_format", 
            "to_format"
        ], 
        "params": [
            [
                "'csr'", 
                "'csc'", 
                "'coo'", 
                "'dia'", 
                "'lil'", 
                "'dok'"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'coo'", 
                "'dia'", 
                "'lil'", 
                "'dok'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "a9d442f1263249260251f49b77ff6686cf2dc96b46575ddc42b766e91c588af5", 
        "warmup_time": -1
    }, 
    "sparse.Densify.time_toarray": {
        "code": "class Densify:\n    def time_toarray(self, format, order):\n        self.X.toarray(order=order)\n\n    def setup(self, format, order):\n        self.X = sparse.rand(1000, 1000, format=format, density=0.01)", 
        "min_run_count": 2, 
        "name": "sparse.Densify.time_toarray", 
        "number": 0, 
        "param_names": [
            "format", 
            "order"
        ], 
        "params": [
            [
                "'dia'", 
                "'csr'", 
                "'csc'", 
                "'dok'", 
                "'lil'", 
                "'coo'", 
                "'bsr'"
            ], 
            [
                "'C'", 
                "'F'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "2fbf492ec800b982946a62785beda803460b913cc80080043a5d407025893b2b", 
        "warmup_time": -1
    }, 
    "sparse.Diagonal.time_diagonal": {
        "code": "class Diagonal:\n    def time_diagonal(self, density, format):\n        self.X.diagonal()\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        self.X = sparse.rand(n, n, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.Diagonal.time_diagonal", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.01", 
                "0.1", 
                "0.5"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'coo'", 
                "'lil'", 
                "'dok'", 
                "'dia'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "d84f53fdc6abc208136c8ce48ca156370f6803562f6908eb6bd1424f50310cf1", 
        "warmup_time": -1
    }, 
    "sparse.Getset.time_fancy_getitem": {
        "code": "class Getset:\n    def time_fancy_getitem(self, N, sparsity_pattern, format):\n        self.m[self.i, self.j]\n\n    def setup(self, N, sparsity_pattern, format):\n        if format == 'dok' and N > 500:\n            raise NotImplementedError()\n    \n        self.A = rand(1000, 1000, density=1e-5)\n    \n        A = self.A\n        N = int(N)\n    \n        # indices to assign to\n        i, j = [], []\n        while len(i) < N:\n            n = N - len(i)\n            ip = numpy.random.randint(0, A.shape[0], size=n)\n            jp = numpy.random.randint(0, A.shape[1], size=n)\n            i = numpy.r_[i, ip]\n            j = numpy.r_[j, jp]\n        v = numpy.random.rand(n)\n    \n        if N == 1:\n            i = int(i)\n            j = int(j)\n            v = float(v)\n    \n        base = A.asformat(format)\n    \n        self.m = base.copy()\n        self.i = i\n        self.j = j\n        self.v = v", 
        "min_run_count": 2, 
        "name": "sparse.Getset.time_fancy_getitem", 
        "number": 0, 
        "param_names": [
            "N", 
            "sparsity pattern", 
            "format"
        ], 
        "params": [
            [
                "1", 
                "10", 
                "100", 
                "1000", 
                "10000"
            ], 
            [
                "'different'", 
                "'same'"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'", 
                "'dok'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "db8f9fd8e5a7a1e507d59c8f0cca32bdfe0a50d43dde3bced0592759da801ea2", 
        "warmup_time": -1
    }, 
    "sparse.Getset.track_fancy_setitem": {
        "code": "class Getset:\n    def track_fancy_setitem(self, N, sparsity_pattern, format):\n        def kernel(A, i, j, v):\n            A[i, j] = v\n    \n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', SparseEfficiencyWarning)\n            return self._timeit(kernel, sparsity_pattern == 'different')\n\n    def setup(self, N, sparsity_pattern, format):\n        if format == 'dok' and N > 500:\n            raise NotImplementedError()\n    \n        self.A = rand(1000, 1000, density=1e-5)\n    \n        A = self.A\n        N = int(N)\n    \n        # indices to assign to\n        i, j = [], []\n        while len(i) < N:\n            n = N - len(i)\n            ip = numpy.random.randint(0, A.shape[0], size=n)\n            jp = numpy.random.randint(0, A.shape[1], size=n)\n            i = numpy.r_[i, ip]\n            j = numpy.r_[j, jp]\n        v = numpy.random.rand(n)\n    \n        if N == 1:\n            i = int(i)\n            j = int(j)\n            v = float(v)\n    \n        base = A.asformat(format)\n    \n        self.m = base.copy()\n        self.i = i\n        self.j = j\n        self.v = v", 
        "name": "sparse.Getset.track_fancy_setitem", 
        "param_names": [
            "N", 
            "sparsity pattern", 
            "format"
        ], 
        "params": [
            [
                "1", 
                "10", 
                "100", 
                "1000", 
                "10000"
            ], 
            [
                "'different'", 
                "'same'"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'", 
                "'dok'"
            ]
        ], 
        "timeout": 60.0, 
        "type": "track", 
        "unit": "seconds", 
        "version": "d0a713aadd72a514aeaa359421b2323d0781bf2626876b398b7c667ccebabffd"
    }, 
    "sparse.Iteration.time_iteration": {
        "code": "class Iteration:\n    def time_iteration(self, density, format):\n        for row in self.X:\n            pass\n\n    def setup(self, density, format):\n        n = 500\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.Iteration.time_iteration", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "fbefcb7469069e5c8675880657b3349b1035a37fbda9ae186e6f9351967c2ee4", 
        "warmup_time": -1
    }, 
    "sparse.Matmul.time_large": {
        "code": "class Matmul:\n    def time_large(self):\n        for i in range(100):\n            self.matrix1 * self.matrix2\n\n    def setup(self):\n        H1, W1 = 1, 100000\n        H2, W2 = W1, 1000\n        C1 = 10\n        C2 = 1000000\n    \n        random.seed(0)\n    \n        matrix1 = lil_matrix(zeros((H1, W1)))\n        matrix2 = lil_matrix(zeros((H2, W2)))\n        for i in range(C1):\n            matrix1[random.randint(H1), random.randint(W1)] = random.rand()\n        for i in range(C2):\n            matrix2[random.randint(H2), random.randint(W2)] = random.rand()\n        self.matrix1 = matrix1.tocsr()\n        self.matrix2 = matrix2.tocsr()", 
        "min_run_count": 2, 
        "name": "sparse.Matmul.time_large", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "33aee08539377a7cb0fabaf0d9ff9d6d80079a428873f451b378c39f6ead48cb", 
        "warmup_time": -1
    }, 
    "sparse.Matvec.time_matvec": {
        "code": "class Matvec:\n    def time_matvec(self, matrix, format):\n        self.A * self.x\n\n    def setup(self, matrix, format):\n        if matrix == 'Identity':\n            if format in ('lil', 'dok'):\n                raise NotImplementedError()\n            self.A = sparse.eye(10000, 10000, format=format)\n        elif matrix == 'Poisson5pt':\n            self.A = poisson2d(300, format=format)\n        elif matrix == 'Block2x2':\n            if format not in ('csr', 'bsr'):\n                raise NotImplementedError()\n            b = (2, 2)\n            self.A = sparse.kron(poisson2d(150),\n                                 ones(b)).tobsr(blocksize=b).asformat(format)\n        elif matrix == 'Block3x3':\n            if format not in ('csr', 'bsr'):\n                raise NotImplementedError()\n            b = (3, 3)\n            self.A = sparse.kron(poisson2d(100),\n                                 ones(b)).tobsr(blocksize=b).asformat(format)\n        else:\n            raise NotImplementedError()\n    \n        self.x = ones(self.A.shape[1], dtype=float)", 
        "min_run_count": 2, 
        "name": "sparse.Matvec.time_matvec", 
        "number": 0, 
        "param_names": [
            "matrix", 
            "format"
        ], 
        "params": [
            [
                "'Identity'", 
                "'Poisson5pt'", 
                "'Block2x2'", 
                "'Block3x3'"
            ], 
            [
                "'dia'", 
                "'csr'", 
                "'csc'", 
                "'dok'", 
                "'lil'", 
                "'coo'", 
                "'bsr'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8becb02aa64d32a3defee8b0229f7e63128c6ca3463a313a08af8448d05c017d", 
        "warmup_time": -1
    }, 
    "sparse.Matvecs.time_matvecs": {
        "code": "class Matvecs:\n    def time_matvecs(self, format):\n        self.A * self.x\n\n    def setup(self, format):\n        self.A = poisson2d(300, format=format)\n        self.x = ones((self.A.shape[1], 10), dtype=self.A.dtype)", 
        "min_run_count": 2, 
        "name": "sparse.Matvecs.time_matvecs", 
        "number": 0, 
        "param_names": [
            "format"
        ], 
        "params": [
            [
                "'dia'", 
                "'coo'", 
                "'csr'", 
                "'csc'", 
                "'bsr'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0e6c8e3b6d833c713ee6b32da28ca78fec9f77bb427c6f5db2956d2f3688d46c", 
        "warmup_time": -1
    }, 
    "sparse.NullSlice.time_10000_rows": {
        "code": "class NullSlice:\n    def time_10000_rows(self, density, format):\n        self.X[np.arange(10000), :]\n\n    def setup(self, density, format):\n        n = 100000\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.NullSlice.time_10000_rows", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "dc19210b894d5fd41d4563f85b7459ef5836cddaf77154b539df3ea91c5d5c1c", 
        "warmup_time": -1
    }, 
    "sparse.NullSlice.time_100_cols": {
        "code": "class NullSlice:\n    def time_100_cols(self, density, format):\n        self.X[:, np.arange(100)]\n\n    def setup(self, density, format):\n        n = 100000\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.NullSlice.time_100_cols", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8d43ed52084cdab150018eedb289a749a39f35d4dfa31f53280f1ef286a23046", 
        "warmup_time": -1
    }, 
    "sparse.NullSlice.time_3_cols": {
        "code": "class NullSlice:\n    def time_3_cols(self, density, format):\n        self.X[:, [0, 100, 105]]\n\n    def setup(self, density, format):\n        n = 100000\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.NullSlice.time_3_cols", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "93e5123910772d62b3f72abff56c2732f83d217221bce409b70e77b89c311d26", 
        "warmup_time": -1
    }, 
    "sparse.NullSlice.time_3_rows": {
        "code": "class NullSlice:\n    def time_3_rows(self, density, format):\n        self.X[[0, 100, 105], :]\n\n    def setup(self, density, format):\n        n = 100000\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.NullSlice.time_3_rows", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "a9eac80863a0b2f4b510269955041930e5fdd15607238257eb78244f891ebfe6", 
        "warmup_time": -1
    }, 
    "sparse.NullSlice.time_getcol": {
        "code": "class NullSlice:\n    def time_getcol(self, density, format):\n        self.X.getcol(100)\n\n    def setup(self, density, format):\n        n = 100000\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.NullSlice.time_getcol", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "291388763b355f0f3935db9272a29965d14fa3f305d3306059381e15300e638b", 
        "warmup_time": -1
    }, 
    "sparse.NullSlice.time_getrow": {
        "code": "class NullSlice:\n    def time_getrow(self, density, format):\n        self.X.getrow(100)\n\n    def setup(self, density, format):\n        n = 100000\n        k = 1000\n        self.X = sparse.rand(n, k, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.NullSlice.time_getrow", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.05", 
                "0.01"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'lil'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "edb9e4291560d6ba8dd58ef371b3a343a333bc10744496adb3ff964762d33c68", 
        "warmup_time": -1
    }, 
    "sparse.Sort.time_sort": {
        "code": "class Sort:\n    def time_sort(self, matrix):\n        \"\"\"sort CSR column indices\"\"\"\n        self.A.sort_indices()\n\n    def setup(self, matrix):\n        n = 10000\n        if matrix.startswith('Rand'):\n            k = int(matrix[4:])\n            self.A = random_sparse(n, n, k)\n            self.A.has_sorted_indices = False\n            self.A.indices[:2] = 2, 1\n        else:\n            raise NotImplementedError()", 
        "min_run_count": 2, 
        "name": "sparse.Sort.time_sort", 
        "number": 0, 
        "param_names": [
            "matrix"
        ], 
        "params": [
            [
                "'Rand10'", 
                "'Rand25'", 
                "'Rand50'", 
                "'Rand100'", 
                "'Rand200'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "4268949f8dfc20462c34ad9701546d2d0354296a0031229c0dcf602f5b745973", 
        "warmup_time": -1
    }, 
    "sparse.Sum.time_sum": {
        "code": "class Sum:\n    def time_sum(self, density, format):\n        self.X.sum()\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        self.X = sparse.rand(n, n, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.Sum.time_sum", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.01", 
                "0.1", 
                "0.5"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'coo'", 
                "'lil'", 
                "'dok'", 
                "'dia'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "05c305857e771024535e546360203b17f5aca2b39b023a49ab296bd746d6cdd3", 
        "warmup_time": -1
    }, 
    "sparse.Sum.time_sum_axis0": {
        "code": "class Sum:\n    def time_sum_axis0(self, density, format):\n        self.X.sum(axis=0)\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        self.X = sparse.rand(n, n, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.Sum.time_sum_axis0", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.01", 
                "0.1", 
                "0.5"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'coo'", 
                "'lil'", 
                "'dok'", 
                "'dia'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "8aca682fd69aa140c69c028679826bdf43c717589b1961b4702d744ed72effc6", 
        "warmup_time": -1
    }, 
    "sparse.Sum.time_sum_axis1": {
        "code": "class Sum:\n    def time_sum_axis1(self, density, format):\n        self.X.sum(axis=1)\n\n    def setup(self, density, format):\n        n = 1000\n        if format == 'dok' and n * density >= 500:\n            raise NotImplementedError()\n    \n        self.X = sparse.rand(n, n, format=format, density=density)", 
        "min_run_count": 2, 
        "name": "sparse.Sum.time_sum_axis1", 
        "number": 0, 
        "param_names": [
            "density", 
            "format"
        ], 
        "params": [
            [
                "0.01", 
                "0.1", 
                "0.5"
            ], 
            [
                "'csr'", 
                "'csc'", 
                "'coo'", 
                "'lil'", 
                "'dok'", 
                "'dia'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "1a6e05244b77f857c61f8ee09ca3abd006a10ba07eff10b1c5f9e0ac20f331b2", 
        "warmup_time": -1
    }, 
    "sparse_csgraph.Laplacian.time_laplacian": {
        "code": "class Laplacian:\n    def time_laplacian(self, n, format, normed):\n        laplacian(self.A, normed=normed)\n\n    def setup(self, n, format, normed):\n        data = scipy.sparse.rand(9, n, density=0.5, random_state=42).toarray()\n        data = np.vstack((data, data))\n        diags = list(range(-9, 0)) + list(range(1, 10))\n        A = scipy.sparse.spdiags(data, diags, n, n)\n        if format == 'dense':\n            self.A = A.toarray()\n        else:\n            self.A = A.asformat(format)", 
        "min_run_count": 2, 
        "name": "sparse_csgraph.Laplacian.time_laplacian", 
        "number": 0, 
        "param_names": [
            "n", 
            "format", 
            "normed"
        ], 
        "params": [
            [
                "30", 
                "300", 
                "900"
            ], 
            [
                "'dense'", 
                "'coo'", 
                "'csc'", 
                "'csr'", 
                "'dia'"
            ], 
            [
                "True", 
                "False"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "b92e9b88ee4c528c25ebb2cfe70b49009ea6137919484946765b5321b04dc79e", 
        "warmup_time": -1
    }, 
    "sparse_linalg_expm.Expm.time_expm": {
        "code": "class Expm:\n    def time_expm(self, n, format):\n        if format == 'sparse':\n            scipy.linalg.expm(self.A_sparse)\n        elif format == 'dense':\n            scipy.linalg.expm(self.A_dense)\n\n    def setup(self, n, format):\n        np.random.seed(1234)\n    \n        # Let the number of nonzero entries per row\n        # scale like the log of the order of the matrix.\n        nnz_per_row = int(math.ceil(math.log(n)))\n    \n        # time the sampling of a random sparse matrix\n        self.A_sparse = random_sparse_csc(n, n, nnz_per_row)\n    \n        # first format conversion\n        self.A_dense = self.A_sparse.toarray()", 
        "min_run_count": 2, 
        "name": "sparse_linalg_expm.Expm.time_expm", 
        "number": 0, 
        "param_names": [
            "n", 
            "format"
        ], 
        "params": [
            [
                "30", 
                "100", 
                "300"
            ], 
            [
                "'sparse'", 
                "'dense'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "5b030fdc90211e607b049fdc2559bc5c21dae416c78149ccdf5084f8d8b863b0", 
        "warmup_time": -1
    }, 
    "sparse_linalg_expm.ExpmMultiply.time_expm_multiply": {
        "code": "class ExpmMultiply:\n    def time_expm_multiply(self, format):\n        if format == 'full':\n            # computing full expm of the dense array...\n            A_expm = scipy.linalg.expm(self.A_dense)\n            A_expm[self.i, self.j]\n        else:\n            # computing only column', j, 'of expm of the sparse matrix...\n            v = np.zeros(self.n, dtype=float)\n            v[self.j] = 1\n            A_expm_col_j = expm_multiply(self.A, v)\n            A_expm_col_j[self.i]\n\n    def setup(self, *args):\n        self.n = 2000\n        self.i = 100\n        self.j = 200\n        nnz_per_row = 25\n        self.A = random_sparse_csr(self.n, self.n, nnz_per_row)\n        self.A_dense = self.A.toarray()", 
        "min_run_count": 2, 
        "name": "sparse_linalg_expm.ExpmMultiply.time_expm_multiply", 
        "number": 0, 
        "param_names": [
            "run format"
        ], 
        "params": [
            [
                "'sparse'", 
                "'full'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "52a520179de50cd96854d82dade9a35ee90b7774f24468423c9828b423daaa13", 
        "warmup_time": -1
    }, 
    "sparse_linalg_lobpcg.Bench.time_mikota": {
        "code": "class Bench:\n    def time_mikota(self, n, solver):\n        m = 10\n        if solver == 'lobpcg':\n            X = rand(n, m)\n            X = orth(X)\n            LorU, lower = cho_factor(self.A, lower=0, overwrite_a=0)\n            M = LinearOperator(self.shape,\n                               matvec=partial(_precond, LorU, lower),\n                               matmat=partial(_precond, LorU, lower))\n            eigs, vecs = lobpcg(self.A, X, self.B, M, tol=1e-4, maxiter=40)\n        else:\n            eigh(self.A, self.B, eigvals_only=True, eigvals=(0, m - 1))\n\n    def setup_mikota(self, n, solver):\n        self.shape = (n, n)\n        self.A, self.B = _mikota_pair(n)", 
        "min_run_count": 2, 
        "name": "sparse_linalg_lobpcg.Bench.time_mikota", 
        "number": 0, 
        "param_names": [
            "n", 
            "solver"
        ], 
        "params": [
            [
                "128", 
                "256", 
                "512", 
                "1024", 
                "2048"
            ], 
            [
                "'lobpcg'", 
                "'eigh'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "a1fb679758f7e5cf79d18cc4930afdff999fccc142fe7a4f63e73b39ab1f58bb", 
        "warmup_time": -1
    }, 
    "sparse_linalg_lobpcg.Bench.time_sakurai": {
        "code": "class Bench:\n    def time_sakurai(self, n, solver):\n        m = 3\n        if solver == 'lobpcg':\n            X = rand(n, m)\n            eigs, vecs, resnh = lobpcg(self.A, X, self.B, tol=1e-6, maxiter=500,\n                                       retResidualNormsHistory=1)\n        else:\n            eigh(self.A_dense, self.B_dense, eigvals_only=True, eigvals=(0, m - 1))\n\n    def setup_sakurai(self, n, solver):\n        self.shape = (n, n)\n        self.A, self.B, all_eigenvalues = _sakurai(n)\n        self.A_dense = self.A.A\n        self.B_dense = self.B.A", 
        "min_run_count": 2, 
        "name": "sparse_linalg_lobpcg.Bench.time_sakurai", 
        "number": 0, 
        "param_names": [
            "n", 
            "solver"
        ], 
        "params": [
            [
                "50", 
                "400", 
                "2400"
            ], 
            [
                "'lobpcg'", 
                "'eigh'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "7c38d449924fb71f777bd408072ecc883b8b05e53a6544e97da3887fbc10b235", 
        "warmup_time": -1
    }, 
    "sparse_linalg_onenormest.BenchmarkOneNormEst.time_onenormest": {
        "code": "class BenchmarkOneNormEst:\n    def time_onenormest(self, n, solver):\n        if solver == 'exact':\n            # Get the exact values of one-norms of squares.\n            for M in self.matrices:\n                M.dot(M)\n                scipy.sparse.linalg.matfuncs._onenorm(M)\n        elif solver == 'onenormest':\n            # Get the estimates of one-norms of squares.\n            for M in self.matrices:\n                scipy.sparse.linalg.matfuncs._onenormest_matrix_power(M, 2)\n\n    def setup(self, n, solver):\n        np.random.seed(1234)\n        nrepeats = 100\n        shape = (n, n)\n    \n        if n <= 1000:\n            # Sample the matrices.\n            self.matrices = []\n            for i in range(nrepeats):\n                M = np.random.randn(*shape)\n                self.matrices.append(M)\n        else:\n            if solver == 'exact':\n                raise NotImplementedError()\n    \n            max_nnz = 100000\n            nrepeats = 1\n    \n            self.matrices = []\n            for i in range(nrepeats):\n                M = scipy.sparse.rand(shape[0], shape[1], min(max_nnz/(shape[0]*shape[1]), 1e-5))\n                self.matrices.append(M)", 
        "min_run_count": 2, 
        "name": "sparse_linalg_onenormest.BenchmarkOneNormEst.time_onenormest", 
        "number": 0, 
        "param_names": [
            "n", 
            "solver"
        ], 
        "params": [
            [
                "2", 
                "3", 
                "5", 
                "10", 
                "30", 
                "100", 
                "300", 
                "500", 
                "1000", 
                "10000.0", 
                "100000.0", 
                "1000000.0"
            ], 
            [
                "'exact'", 
                "'onenormest'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "f7b31b4bf5caa50d435465e78dab6e133f3c263a52c4523eec785446185fdb6f", 
        "warmup_time": -1
    }, 
    "sparse_linalg_solve.Bench.time_solve": {
        "code": "class Bench:\n    def time_solve(self, n, solver):\n        if solver == 'dense':\n            linalg.solve(self.P_dense, self.b)\n        elif solver == 'cg':\n            cg(self.P_sparse, self.b)\n        elif solver == 'minres':\n            minres(self.P_sparse, self.b)\n        elif solver == 'gmres':\n            gmres(self.P_sparse, self.b)\n        elif solver == 'lgmres':\n            lgmres(self.P_sparse, self.b)\n        elif solver == 'gcrotmk':\n            gcrotmk(self.P_sparse, self.b)\n        elif solver == 'spsolve':\n            spsolve(self.P_sparse, self.b)\n        else:\n            raise ValueError('Unknown solver: %r' % solver)\n\n    def setup(self, n, solver):\n        if solver == 'dense' and n >= 25:\n            raise NotImplementedError()\n    \n        self.b = np.ones(n*n)\n        self.P_sparse = _create_sparse_poisson2d(n)\n    \n        if solver == 'dense':\n            self.P_dense = self.P_sparse.A", 
        "min_run_count": 2, 
        "name": "sparse_linalg_solve.Bench.time_solve", 
        "number": 0, 
        "param_names": [
            "(n,n)", 
            "solver"
        ], 
        "params": [
            [
                "4", 
                "6", 
                "10", 
                "16", 
                "25", 
                "40", 
                "64", 
                "100"
            ], 
            [
                "'dense'", 
                "'spsolve'", 
                "'cg'", 
                "'minres'", 
                "'gmres'", 
                "'lgmres'", 
                "'gcrotmk'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "31a8ef9e4f642dff8bf29be4a8d79e1d3c776514bd30682b111a56e70ed7f6da", 
        "warmup_time": -1
    }, 
    "sparse_linalg_solve.Lgmres.time_inner": {
        "code": "class Lgmres:\n    def time_inner(self, n, m):\n        lgmres(self.A, self.b, inner_m=m, maxiter=1)\n\n    def setup(self, n, m):\n        np.random.seed(1234)\n        self.A = sparse.eye(n, n) + sparse.rand(n, n, density=0.01)\n        self.b = np.ones(n)", 
        "min_run_count": 2, 
        "name": "sparse_linalg_solve.Lgmres.time_inner", 
        "number": 0, 
        "param_names": [
            "n", 
            "m"
        ], 
        "params": [
            [
                "10", 
                "50", 
                "100", 
                "1000", 
                "10000"
            ], 
            [
                "10", 
                "30", 
                "60", 
                "90", 
                "180"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "7a87045c1ddaa5704fb262800ad4c1dde101dc556a9445db9dd76c4029193f2d", 
        "warmup_time": -1
    }, 
    "spatial.Build.time_build": {
        "code": "class Build:\n    def time_build(self, mnr, cls_name):\n        \"\"\"\n        Constructing kd-tree\n        =======================\n        dim | # points |  time\n        \"\"\"\n        m, n, r = mnr\n        if cls_name == 'cKDTree_flat':\n            self.T = self.cls(self.data, leafsize=n)\n        else:\n            self.cls(self.data)\n\n    def setup(self, mnr, cls_name):\n        self.cls = KDTree if cls_name == 'KDTree' else cKDTree\n        m, n, r = mnr\n    \n        np.random.seed(1234)\n        self.data = np.concatenate((np.random.randn(n//2,m),\n                                    np.random.randn(n-n//2,m)+np.ones(m)))\n    \n        self.queries = np.concatenate((np.random.randn(r//2,m),\n                                       np.random.randn(r-r//2,m)+np.ones(m)))", 
        "min_run_count": 2, 
        "name": "spatial.Build.time_build", 
        "number": 0, 
        "param_names": [
            "(m, n, r)", 
            "class"
        ], 
        "params": [
            [
                "(3, 10000, 1000)", 
                "(8, 10000, 1000)", 
                "(16, 10000, 1000)"
            ], 
            [
                "'KDTree'", 
                "'cKDTree'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "4ba4812dbaf8d690c45fa276a5f1b3b65d132471009316c8554e20445e8c7924", 
        "warmup_time": -1
    }, 
    "spatial.CNeighbors.time_count_neighbors_deep": {
        "code": "class CNeighbors:\n    def time_count_neighbors_deep(self, mn1n2, Nr):\n        \"\"\"\n        Count neighbors for a very deep kd-tree\n        dim | # points T1 | # points T2 | Nr\n        \"\"\"\n        self.T1d.count_neighbors(self.T2d, self.r)\n\n    def setup(self, mn1n2, Nr):\n        m, n1, n2 = mn1n2\n    \n        data1 = np.random.uniform(size=(n1, m))\n        data2 = np.random.uniform(size=(n2, m))\n        self.w1 = np.ones(len(data1))\n        self.w2 = np.ones(len(data2))\n    \n        self.T1d = cKDTree(data1, leafsize=1)\n        self.T2d = cKDTree(data2, leafsize=1)\n        self.T1s = cKDTree(data1, leafsize=8)\n        self.T2s = cKDTree(data2, leafsize=8)\n        self.r = np.linspace(0, 0.5, Nr)", 
        "min_run_count": 2, 
        "name": "spatial.CNeighbors.time_count_neighbors_deep", 
        "number": 0, 
        "param_names": [
            "(m, n1, n2)", 
            "Nr"
        ], 
        "params": [
            [
                "(2, 1000, 1000)", 
                "(8, 1000, 1000)", 
                "(16, 1000, 1000)"
            ], 
            [
                "2", 
                "10", 
                "100", 
                "400", 
                "1000"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "898c532420fe54ed2c5c8ac138c47fb2c526cc6068b1af36f4bb77fe14cbc921", 
        "warmup_time": -1
    }, 
    "spatial.CNeighbors.time_count_neighbors_shallow": {
        "code": "class CNeighbors:\n    def time_count_neighbors_shallow(self, mn1n2, Nr):\n        \"\"\"\n        Count neighbors for a shallow kd-tree\n        dim | # points T1 | # points T2 | Nr\n        \"\"\"\n        self.T1s.count_neighbors(self.T2s, self.r)\n\n    def setup(self, mn1n2, Nr):\n        m, n1, n2 = mn1n2\n    \n        data1 = np.random.uniform(size=(n1, m))\n        data2 = np.random.uniform(size=(n2, m))\n        self.w1 = np.ones(len(data1))\n        self.w2 = np.ones(len(data2))\n    \n        self.T1d = cKDTree(data1, leafsize=1)\n        self.T2d = cKDTree(data2, leafsize=1)\n        self.T1s = cKDTree(data1, leafsize=8)\n        self.T2s = cKDTree(data2, leafsize=8)\n        self.r = np.linspace(0, 0.5, Nr)", 
        "min_run_count": 2, 
        "name": "spatial.CNeighbors.time_count_neighbors_shallow", 
        "number": 0, 
        "param_names": [
            "(m, n1, n2)", 
            "Nr"
        ], 
        "params": [
            [
                "(2, 1000, 1000)", 
                "(8, 1000, 1000)", 
                "(16, 1000, 1000)"
            ], 
            [
                "2", 
                "10", 
                "100", 
                "400", 
                "1000"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "77ff53b15a90b2222e3a224e25ae752587a0a69b3899f04a8689193cda97f368", 
        "warmup_time": -1
    }, 
    "spatial.Cdist.time_cdist": {
        "code": "class Cdist:\n    def time_cdist(self, num_points, metric):\n        \"\"\"Time scipy.spatial.distance.cdist over a range of input data\n        sizes and metrics.\n        \"\"\"\n        distance.cdist(self.points, self.points, metric)\n\n    def setup(self, num_points, metric):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))", 
        "min_run_count": 2, 
        "name": "spatial.Cdist.time_cdist", 
        "number": 0, 
        "param_names": [
            "num_points", 
            "metric"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000"
            ], 
            [
                "'euclidean'", 
                "'minkowski'", 
                "'cityblock'", 
                "'seuclidean'", 
                "'sqeuclidean'", 
                "'cosine'", 
                "'correlation'", 
                "'hamming'", 
                "'jaccard'", 
                "'chebyshev'", 
                "'canberra'", 
                "'braycurtis'", 
                "'mahalanobis'", 
                "'yule'", 
                "'dice'", 
                "'kulsinski'", 
                "'rogerstanimoto'", 
                "'russellrao'", 
                "'sokalmichener'", 
                "'sokalsneath'", 
                "'wminkowski'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "1b8a0876e5b8b2049533154019a432ffb4df0aa6442f48a96346237a7f4163e5", 
        "warmup_time": -1
    }, 
    "spatial.ConvexHullBench.time_convex_hull": {
        "code": "class ConvexHullBench:\n    def time_convex_hull(self, num_points, incremental):\n        \"\"\"Time scipy.spatial.ConvexHull over a range of input data sizes\n        and settings.\n        \"\"\"\n        ConvexHull(self.points, incremental)\n\n    def setup(self, num_points, incremental):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))", 
        "min_run_count": 2, 
        "name": "spatial.ConvexHullBench.time_convex_hull", 
        "number": 0, 
        "param_names": [
            "num_points", 
            "incremental"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000", 
                "5000"
            ], 
            [
                "True", 
                "False"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "64fda6560789a5a6261b84ec4eaa9f416b469f162f374ee0bfda0ecff981f12a", 
        "warmup_time": -1
    }, 
    "spatial.Hausdorff.time_directed_hausdorff": {
        "code": "class Hausdorff:\n    def time_directed_hausdorff(self, num_points):\n        # time directed_hausdorff code in 3 D\n        distance.directed_hausdorff(self.points1, self.points2)\n\n    def setup(self, num_points):\n        np.random.seed(123)\n        self.points1 = np.random.random_sample((num_points, 3))\n        np.random.seed(71890)\n        self.points2 = np.random.random_sample((num_points, 3))", 
        "min_run_count": 2, 
        "name": "spatial.Hausdorff.time_directed_hausdorff", 
        "number": 0, 
        "param_names": [
            "num_points"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "4c3ada8182e009f3f38b3468aebf2a21211aa46f4b9468985624a9b89a17f539", 
        "warmup_time": -1
    }, 
    "spatial.Neighbors.time_count_neighbors": {
        "code": "class Neighbors:\n    def time_count_neighbors(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        \"\"\"\n        Count neighbors kd-tree\n        dim | # points T1 | # points T2 | p | probe radius |  BoxSize | LeafSize | cls\n        \"\"\"\n    \n        if cls != 'cKDTree_weighted':\n            self.T1.count_neighbors(self.T2, probe_radius, p=p)\n        else:\n            self.T1.count_neighbors(self.T2, probe_radius, weights=(self.w1, self.w2), p=p)\n\n    def setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        m, n1, n2 = mn1n2\n    \n        self.data1 = np.random.uniform(size=(n1, m))\n        self.data2 = np.random.uniform(size=(n2, m))\n    \n        self.w1 = np.ones(n1)\n        self.w2 = np.ones(n2)\n    \n        self.T1 = cKDTree(self.data1, boxsize=boxsize, leafsize=leafsize)\n        self.T2 = cKDTree(self.data2, boxsize=boxsize, leafsize=leafsize)", 
        "min_run_count": 2, 
        "name": "spatial.Neighbors.time_count_neighbors", 
        "number": 0, 
        "param_names": [
            "(m, n1, n2)", 
            "p", 
            "probe radius", 
            "boxsize", 
            "leafsize", 
            "cls"
        ], 
        "params": [
            [
                "(3, 1000, 1000)", 
                "(8, 1000, 1000)", 
                "(16, 1000, 1000)"
            ], 
            [
                "1", 
                "2", 
                "inf"
            ], 
            [
                "0.2", 
                "0.5"
            ], 
            [
                "None", 
                "0.0", 
                "1.0"
            ], 
            [
                "8", 
                "128"
            ], 
            [
                "'cKDTree'", 
                "'cKDTree_weighted'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "830287f1cf51fa6ba21854a60b03b2a6c70b2f2485c3cdcfb19a360e0a7e2ca2", 
        "warmup_time": -1
    }, 
    "spatial.Neighbors.time_sparse_distance_matrix": {
        "code": "class Neighbors:\n    def time_sparse_distance_matrix(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        self.T1.sparse_distance_matrix(self.T2, probe_radius, p=p)\n\n    def setup(self, mn1n2, p, probe_radius, boxsize, leafsize, cls):\n        m, n1, n2 = mn1n2\n    \n        self.data1 = np.random.uniform(size=(n1, m))\n        self.data2 = np.random.uniform(size=(n2, m))\n    \n        self.w1 = np.ones(n1)\n        self.w2 = np.ones(n2)\n    \n        self.T1 = cKDTree(self.data1, boxsize=boxsize, leafsize=leafsize)\n        self.T2 = cKDTree(self.data2, boxsize=boxsize, leafsize=leafsize)", 
        "min_run_count": 2, 
        "name": "spatial.Neighbors.time_sparse_distance_matrix", 
        "number": 0, 
        "param_names": [
            "(m, n1, n2)", 
            "p", 
            "probe radius", 
            "boxsize", 
            "leafsize", 
            "cls"
        ], 
        "params": [
            [
                "(3, 1000, 1000)", 
                "(8, 1000, 1000)", 
                "(16, 1000, 1000)"
            ], 
            [
                "1", 
                "2", 
                "inf"
            ], 
            [
                "0.2", 
                "0.5"
            ], 
            [
                "None", 
                "0.0", 
                "1.0"
            ], 
            [
                "8", 
                "128"
            ], 
            [
                "'cKDTree'", 
                "'cKDTree_weighted'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "9aa921dce6da78394ab29d949be27953484613dcf9c9632c01ae3973d4b29596", 
        "warmup_time": -1
    }, 
    "spatial.Query.time_query": {
        "code": "class Query:\n    def time_query(self, mnr, p, boxsize, leafsize):\n        \"\"\"\n        Querying kd-tree\n        dim | # points | # queries |  KDTree  | cKDTree | flat cKDTree\n        \"\"\"\n        self.T.query(self.queries, p=p)\n\n    def setup(self, mnr, p, boxsize, leafsize):\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", 
        "min_run_count": 2, 
        "name": "spatial.Query.time_query", 
        "number": 0, 
        "param_names": [
            "(m, n, r)", 
            "p", 
            "boxsize", 
            "leafsize"
        ], 
        "params": [
            [
                "(3, 10000, 1000)", 
                "(8, 10000, 1000)", 
                "(16, 10000, 1000)"
            ], 
            [
                "1", 
                "2", 
                "inf"
            ], 
            [
                "None", 
                "0.0", 
                "1.0"
            ], 
            [
                "8", 
                "128"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "327bc0627d5387347e9cdcf4c52a550c813bb80a859eeb0f3e5bfe6650a8a1db", 
        "warmup_time": -1
    }, 
    "spatial.Radius.time_query_ball_point": {
        "code": "class Radius:\n    def time_query_ball_point(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_ball_point(self.queries, probe_radius, p=p)\n\n    def setup(self, mnr, p, probe_radius, boxsize, leafsize):\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", 
        "min_run_count": 2, 
        "name": "spatial.Radius.time_query_ball_point", 
        "number": 0, 
        "param_names": [
            "(m, n, r)", 
            "p", 
            "probe radius", 
            "boxsize", 
            "leafsize"
        ], 
        "params": [
            [
                "(3, 10000, 1000)"
            ], 
            [
                "1", 
                "2", 
                "inf"
            ], 
            [
                "0.2", 
                "0.5"
            ], 
            [
                "None", 
                "0.0", 
                "1.0"
            ], 
            [
                "8", 
                "128"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "e0c2074b35db7e5fca01a43b0fba8ab33a15ed73d8573871ea6feb57b3df4168", 
        "warmup_time": -1
    }, 
    "spatial.Radius.time_query_pairs": {
        "code": "class Radius:\n    def time_query_pairs(self, mnr, p, probe_radius, boxsize, leafsize):\n        self.T.query_pairs(probe_radius, p=p)\n\n    def setup(self, mnr, p, probe_radius, boxsize, leafsize):\n        Query.do_setup(self, mnr, p, boxsize, leafsize)", 
        "min_run_count": 2, 
        "name": "spatial.Radius.time_query_pairs", 
        "number": 0, 
        "param_names": [
            "(m, n, r)", 
            "p", 
            "probe radius", 
            "boxsize", 
            "leafsize"
        ], 
        "params": [
            [
                "(3, 1000, 30)", 
                "(8, 1000, 30)", 
                "(16, 1000, 30)"
            ], 
            [
                "1", 
                "2", 
                "inf"
            ], 
            [
                "0.2", 
                "0.5"
            ], 
            [
                "None", 
                "0.0", 
                "1.0"
            ], 
            [
                "8", 
                "128"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "cf669f7d619e81e4a09b28bb3fceaefbdd316d30faf01524ab33d41661a53f56", 
        "warmup_time": -1
    }, 
    "spatial.SphericalVor.time_spherical_voronoi_calculation": {
        "code": "class SphericalVor:\n    def time_spherical_voronoi_calculation(self, num_points):\n        \"\"\"Perform spherical Voronoi calculation, but not the sorting of\n        vertices in the Voronoi polygons.\n        \"\"\"\n        SphericalVoronoi(self.points, radius=1, center=np.zeros(3))\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)", 
        "min_run_count": 2, 
        "name": "spatial.SphericalVor.time_spherical_voronoi_calculation", 
        "number": 0, 
        "param_names": [
            "num_points"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000", 
                "5000", 
                "10000"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "108f4b104274b35e6ca904743fa9210c9aa3d2ca795577921ed22ab709f57684", 
        "warmup_time": -1
    }, 
    "spatial.SphericalVorSort.time_spherical_polygon_vertex_sorting": {
        "code": "class SphericalVorSort:\n    def time_spherical_polygon_vertex_sorting(self, num_points):\n        \"\"\"Time the vertex sorting operation in the Spherical Voronoi\n        code.\n        \"\"\"\n        self.sv.sort_vertices_of_regions()\n\n    def setup(self, num_points):\n        self.points = generate_spherical_points(num_points)\n        self.sv = SphericalVoronoi(self.points, radius=1,\n                                   center=np.zeros(3))", 
        "min_run_count": 2, 
        "name": "spatial.SphericalVorSort.time_spherical_polygon_vertex_sorting", 
        "number": 0, 
        "param_names": [
            "num_points"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000", 
                "5000", 
                "10000"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "0f28dddb4c82c668099fe3a69f65ab059cfb4b7614a4444f0fd6d7c0d8dd7799", 
        "warmup_time": -1
    }, 
    "spatial.VoronoiBench.time_voronoi_calculation": {
        "code": "class VoronoiBench:\n    def time_voronoi_calculation(self, num_points, furthest_site):\n        \"\"\"Time conventional Voronoi diagram calculation.\"\"\"\n        Voronoi(self.points, furthest_site=furthest_site)\n\n    def setup(self, num_points, furthest_site):\n        np.random.seed(123)\n        self.points = np.random.random_sample((num_points, 3))", 
        "min_run_count": 2, 
        "name": "spatial.VoronoiBench.time_voronoi_calculation", 
        "number": 0, 
        "param_names": [
            "num_points", 
            "furthest_site"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000", 
                "5000", 
                "10000"
            ], 
            [
                "False", 
                "True"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "dd0e842221e4a0436f3010524f8b9d77200b59940ad82fcd5509ac808b6f8c9c", 
        "warmup_time": -1
    }, 
    "special.Airy.time_ai_zeros": {
        "code": "class Airy:\n    def time_ai_zeros(self):\n        ai_zeros(100000)", 
        "min_run_count": 2, 
        "name": "special.Airy.time_ai_zeros", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "9dcceb9408571060b6f02873fc4072f931f718ea2f5236772dddfc22332775d9", 
        "warmup_time": -1
    }, 
    "special.Airy.time_bi_zeros": {
        "code": "class Airy:\n    def time_bi_zeros(self):\n        bi_zeros(100000)", 
        "min_run_count": 2, 
        "name": "special.Airy.time_bi_zeros", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "5a9724705235ef858c333ec7dae598b7e1557a4ecb55bf8608e91b5d3def7fc5", 
        "warmup_time": -1
    }, 
    "special.Comb.time_comb_exact": {
        "code": "class Comb:\n    @with_attributes(params=[(10, 100, 1000, 10000), (1, 10, 100)],\n                     param_names=['N', 'k'])\n    def time_comb_exact(self, N, k):\n        comb(N, k, exact=True)\n\n    def setup(self, *args):\n        self.N = np.arange(1, 1000, 50)\n        self.k = np.arange(1, 1000, 50)", 
        "min_run_count": 2, 
        "name": "special.Comb.time_comb_exact", 
        "number": 0, 
        "param_names": [
            "N", 
            "k"
        ], 
        "params": [
            [
                "10", 
                "100", 
                "1000", 
                "10000"
            ], 
            [
                "1", 
                "10", 
                "100"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "640e03cb54bf500a9bb17a4558953841df67530fcc79cc6e256cff86801d934d", 
        "warmup_time": -1
    }, 
    "special.Comb.time_comb_float": {
        "code": "class Comb:\n    def time_comb_float(self):\n        comb(self.N[:,None], self.k[None,:])\n\n    def setup(self, *args):\n        self.N = np.arange(1, 1000, 50)\n        self.k = np.arange(1, 1000, 50)", 
        "min_run_count": 2, 
        "name": "special.Comb.time_comb_float", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "eaba845dac64e3a2ba0e5f67ff1bead19bcf0c033840ec965fc4d85582db711b", 
        "warmup_time": -1
    }, 
    "special.Erf.time_real": {
        "code": "class Erf:\n    def time_real(self, offset):\n        erf(self.rand + offset)\n\n    def setup(self, *args):\n        self.rand = np.random.rand(1e5)", 
        "min_run_count": 2, 
        "name": "special.Erf.time_real", 
        "number": 0, 
        "param_names": [
            "offset"
        ], 
        "params": [
            [
                "0.0", 
                "2.0"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "ef1c7e2d05e6d9819f0d9692ae1f7b4e0ccc120c168b7c66e6771beb1816bb81", 
        "warmup_time": -1
    }, 
    "special.Expn.time_expn_large_n": {
        "code": "class Expn:\n    def time_expn_large_n(self):\n        expn(self.n, self.x)\n\n    def setup(self):\n        n, x = np.arange(50, 500), np.logspace(0, 20, 100)\n        n, x = np.meshgrid(n, x)\n        self.n, self.x = n, x", 
        "min_run_count": 2, 
        "name": "special.Expn.time_expn_large_n", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "1579c9226a7e0ebb2047466a04620c619f219cd514361ff859b0381365c498ab", 
        "warmup_time": -1
    }, 
    "special.Loggamma.time_loggamma_asymptotic": {
        "code": "class Loggamma:\n    def time_loggamma_asymptotic(self):\n        loggamma(self.large_z)\n\n    def setup(self):\n        x, y = np.logspace(3, 5, 10), np.logspace(3, 5, 10)\n        x, y = np.meshgrid(x, y)\n        self.large_z = x + 1j*y", 
        "min_run_count": 2, 
        "name": "special.Loggamma.time_loggamma_asymptotic", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "fc273c10f60175c84fce376754825356457225e1b78d83e3beabbf886352585a", 
        "warmup_time": -1
    }, 
    "stats.Anderson_KSamp.time_anderson_ksamp": {
        "code": "class Anderson_KSamp:\n    def time_anderson_ksamp(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', UserWarning)\n            stats.anderson_ksamp(self.rand)\n\n    def setup(self, *args):\n        self.rand = [np.random.normal(loc=i, size=1000) for i in range(3)]", 
        "min_run_count": 2, 
        "name": "stats.Anderson_KSamp.time_anderson_ksamp", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "339fc253c3add6deadbc1edc1112cf1b1fff85f70f57aeb9dd81e0ea23de9384", 
        "warmup_time": -1
    }, 
    "stats.CorrelationFunctions.time_fisher_exact": {
        "code": "class CorrelationFunctions:\n    def time_fisher_exact(self, alternative):\n        oddsratio, pvalue = stats.fisher_exact(self.a, alternative=alternative)\n\n    def setup(self, mode):\n        a = np.random.rand(2,2) * 10\n        self.a = a", 
        "min_run_count": 2, 
        "name": "stats.CorrelationFunctions.time_fisher_exact", 
        "number": 0, 
        "param_names": [
            "alternative"
        ], 
        "params": [
            [
                "'two-sided'", 
                "'less'", 
                "'greater'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "1b6fbd666591799952616c1c2b9786a0098344fa0a5e28a5b5cdb0df0b62f92a", 
        "warmup_time": -1
    }, 
    "stats.Distribution.time_distribution": {
        "code": "class Distribution:\n    def time_distribution(self, distribution, properties):\n        if distribution == 'gamma':\n            if properties == 'pdf':\n                stats.gamma.pdf(self.x, a=5, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.gamma.cdf(self.x, a=5, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.gamma.rvs(size=1000, a=5, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.gamma.fit(self.x, a=5, loc=4, scale=10)\n        elif distribution == 'cauchy':\n            if properties == 'pdf':\n                stats.cauchy.pdf(self.x, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.cauchy.cdf(self.x, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.cauchy.rvs(size=1000, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.cauchy.fit(self.x, loc=4, scale=10)\n        elif distribution == 'beta':\n            if properties == 'pdf':\n                stats.beta.pdf(self.x, a=5, b=3, loc=4, scale=10)\n            elif properties == 'cdf':\n                stats.beta.cdf(self.x, a=5, b=3, loc=4, scale=10)\n            elif properties == 'rvs':\n                stats.beta.rvs(size=1000, a=5, b=3, loc=4, scale=10)\n            elif properties == 'fit':\n                stats.beta.fit(self.x, a=5, b=3, loc=4, scale=10)\n\n    def setup(self, distribution, properties):\n        np.random.seed(12345678)\n        self.x = np.random.rand(100)", 
        "min_run_count": 2, 
        "name": "stats.Distribution.time_distribution", 
        "number": 0, 
        "param_names": [
            "distribution", 
            "properties"
        ], 
        "params": [
            [
                "'cauchy'", 
                "'gamma'", 
                "'beta'"
            ], 
            [
                "'pdf'", 
                "'cdf'", 
                "'rvs'", 
                "'fit'"
            ]
        ], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "fb22ae5386501008d945783921fe44aef3f82c1dafc40cddfaccaeec38b792b0", 
        "warmup_time": -1
    }, 
    "stats.InferentialStats.time_ttest_ind_diff_var": {
        "code": "class InferentialStats:\n    def time_ttest_ind_diff_var(self):\n        # test different sized sample with different variances\n        stats.ttest_ind(self.a, self.c)\n        stats.ttest_ind(self.a, self.c, equal_var=False)\n\n    def setup(self):\n        np.random.seed(12345678)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=20)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=20)", 
        "min_run_count": 2, 
        "name": "stats.InferentialStats.time_ttest_ind_diff_var", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "6cc7d8eef7288a17bea3b1690475da91b002d18c849985591137bba64ec99438", 
        "warmup_time": -1
    }, 
    "stats.InferentialStats.time_ttest_ind_same_var": {
        "code": "class InferentialStats:\n    def time_ttest_ind_same_var(self):\n        # test different sized sample with variances\n        stats.ttest_ind(self.a, self.b)\n        stats.ttest_ind(self.a, self.b, equal_var=False)\n\n    def setup(self):\n        np.random.seed(12345678)\n        self.a = stats.norm.rvs(loc=5, scale=10, size=500)\n        self.b = stats.norm.rvs(loc=8, scale=10, size=20)\n        self.c = stats.norm.rvs(loc=8, scale=20, size=20)", 
        "min_run_count": 2, 
        "name": "stats.InferentialStats.time_ttest_ind_same_var", 
        "number": 0, 
        "param_names": [], 
        "params": [], 
        "processes": 2, 
        "repeat": 0, 
        "sample_time": 0.01, 
        "timeout": 60.0, 
        "type": "time", 
        "unit": "seconds", 
        "version": "462d2cc05dd76e27f79702bef4899c50a49040a7355fb2872e64decfe9e5f1ec", 
        "warmup_time": -1
    }, 
    "version": 2
}